什么是CAP定理？
C 一致性 A 可用性 P 分区容错性 三者只能满足其二
可用性针对节点出现故障，系统可用；分区容错性针对网络出现问题，系统可用
在分布式系统中，网络异常是不可避免的，所以如果不保证分区容错性，除非节点间网络不会发生异常，这个是不可能的（除非单机系统，单机系统就不是分布式系统）。
分布式系统肯定要实现P
1、Redis中间件 ―-> AP
2、RocketMQ中间件 ―C> AP
3、分布式事务-2pc ―-> CP
4、分布式事务-最大努力尝试 ―> AP
5、Eureka ―> AP

说说CAP理论和BASE理论？
BASE是对CAP的延申
基本可用，软状态，最终一致性

什么是最终一致性？最终一致性实现方式？
数据一致性的协议
两阶段提交协议 准备-->提交，基于事务管理器
三阶段提交协议 事务处理能力询问-->处理后待提交-->提交确认，引入了超时机制
TCC协议 Try commit cancle  基于业务逻辑
Paxos协议
ZAB协议
Raft协议
Quorum协议
Gossip协议
基于消息的最终一致性，失败重试，对账处理
GTS(阿里巴巴开源组件）

什么是一致性Hash？
把服务器ip映射到一个hash环，ip点少的时候会造成hash倾斜（一种加机器（成本高）二种加虚拟节点
计算用户请求的hash值，然后顺时针找最近的一个IP，
单调性
分散性
平衡性

Hash取模与一致性Hash
取模的话总数变动，就得将key重新定位

讲讲分布式事务？
如何实现分布式锁？
如何实现分布式 Session?

如何保证消息的一致性?
生产者到MQ:通过ACK确认
MQ对消息持久化
MQ发送给消费者：通过ACK确认
MQ对消息删除

负载均衡的理解？
轮询，随机，HASH,最小连接，最快相应时间

正向代理和反向代理？
正向代理:服务端不知道真实的客户端是谁
反向代理:客户端不知道真实的服务端是谁

CDN实现原理？
怎么提升系统的QPS和吞吐？
Dubbo的底层实现原理和机制？
client发起一个请求，生成一个唯一标识ID,将方法参数，接口，callback对象封装成一个Object对象
放入到concurrentHashMap(id,Object),然后把Id,接口，方法参数封装成request请求对象到服务端
同时调用callback.get(),如果获取不到，就同步等待，调用callback.wait()
服务处理完成之后返回，通过监听程序：取到返回ID，通过ID，获取对应的callback对象，调用Notify通知

描述一个服务从发布到被消费的详细过程？
分布式系统怎么做服务治理？
消息中间件如何解决消息丢失问题？
Dubbo的服务请求失败怎么处理？
对分布式事务的理解？
如何实现负载均衡,有哪些算法可以实现?
Zookeeper的用途,选举的原理是什么?
讲讲数据的垂直拆分水平拆分？
zookeeper原理和适用场景？
zookeeper watch机制？
redis/zk节点宕机如何处理？

分布式集群下如何做到唯一序列号？
数据库自增，uuid,redis incr,zookeeper

用过哪些MQ,怎么用的,和其他mq比较有什么优缺点,MQ的连接是线程安全的吗？
MQ系统的数据如何保证不丢失？

列举出能想到的数据库分库分表策略？
垂直拆分 （按模块)
水平拆分 （按列）
说说分布式缓存和一致性哈希？

系统内核层面
同步I/O 异步I/O
用户空间和内核空间
进程切换
进程的阻塞
文件描述符
缓存 I/O

- 阻塞 I/O（blocking IO） 两部1将数据拷贝到kernel 2将数据从kernel拷贝到用户内存 两个阶段都被block
- 非阻塞 I/O（nonblocking IO） 用户发起read操作时候，kernel会立刻返回给用户error或者结果，用户需要不断轮询
- I/O 多路复用（ IO multiplexing） 事件驱动模型 select,poll,epoll,单个process可以处理多个I/O，epoll会不断轮询所有的socket，当某个socket有数据到达，就通知用户进程
当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，
select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。
I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。

- 信号驱动 I/O（ signal driven IO）
- 异步 I/O（asynchronous IO）

1.分布式session问题
使用数据库进行session共享
使用redis进行session
使用token加session，token和session都是临时且唯一的，redis的k，v分别是token，session
使用tomcat自带的session同步工具，但是效果不好有延时
在网关层做ip hash操作，确保相同ip的请求可以打到相同的tocmat

2.分布式跨域问题
在响应头中加“access-control-allow-origin”
用nginx或zuul反向代理，请求全都打到反向代理服务器，在通过反向代理服务器发请求，并返回给ajax，在浏览器看来都是同一个系统
用jsonp，将ajax的type设置jsonp，但是jsonp只能支持get请求
ajax打到本系统的某接口，在通过这个接口封装httpclient或其他rpc框架发请求

3.分布式任务调度
xxl-job

4.分步式事务
lcn框架

5.分布式幂等性

6.分布式锁
基于数据库，基于redission，基于zookeeper


RPC和MQ的区别和关联

1.在架构上，RPC和MQ的差异点是，Message有一个中间结点Message Queue，可以把消息存储。
2.同步调用：对于要立即等待返回处理结果的场景，RPC是首选
3.MQ 的使用，一方面是基于性能的考虑，比如服务端不能快速的响应客户端（或客户端也不要求实时响应），需要在队列里缓存。
另外一方面，它更侧重数据的传输，因此方式更加多样化，除了点对点外，还有订阅发布等功能。
4.而且随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用改造为异步调用，这个时候可以考虑使用MQ。

引入mq带来的问题
1如何保证消息幂等
2可靠传输（生产者丢数据，mq丢数据，消费者丢数据）
3消息堆积
4消息顺序

https://blog.csdn.net/kunyus/article/details/90670710
微服务
它的主要特点是组件化、松耦合、自治、去中心化
根据业务模块划分服务种类。
每个服务可以独立部署并且互相隔离。
通过轻量的 API 调用服务。
服务需要保证良好的高可用性。
微服务能够使我们的开发效率更高，沟通成本更低，响应速度更快，迭代周期更短
单体应用被分解成多个更小的服务，每个服务有自己的归档文件，单独部署，然后共同组成一个应用程序
微服务有如下优点：
微服务是松藕合的，无论是在开发阶段或部署阶段都是独立的。
能够快速响应, 局部修改容易, 一个服务出现问题不会影响整个应用。
易于和第三方应用系统集成, 支持使用不同的语言开发, 允许你利用融合最新技术。
每个微服务都很小，足够内聚，足够小，代码容易理解。团队能够更关注自己的工作成果, 聚焦指定的业务功能或业务需求。
开发简单、开发效率提高，一个服务可能就是专一的只干一件事, 能够被小团队单独开发，这个小团队可以是 2 到 5 人的开发人员组成。
同样的, 也存在如下缺点:
微服务架构带来过多的运维操作, 可能需要团队具备一定的 DevOps 技巧.
分布式系统可能复杂难以管理。因为分布部署跟踪问题难。当服务数量增加，管理复杂性增加。

单块架构应用：功能集中，代码和数据中心化，一个发布包部署后运行在同一个进程中的应用程序
优点
开发简单直接，集中式管理, 基本不会重复开发
功能都在本地，没有分布式的管理开销和调用开销。
缺点
开发效率低：所有的开发在一个项目改代码，递交代码相互等待，代码冲突不断
代码维护难：代码功能耦合在一起，新人不知道何从下手
部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长
稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉
扩展性不够：无法满足高并发情况下的业务需求