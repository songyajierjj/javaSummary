Java 内存分配？
程序计数器，虚拟机栈，本地方法栈，堆，方法区
Java 堆的结构是什么样子的？
新生代（Eden,from/to） 1/3,老年代 2/3

什么是堆中的永久代（Perm Gen space）?
方法区，存储class、运行时常量池、字段、方法、代码、JIT代码等，是一个规范，规定了这个里面要存储什么东西
永久代是方法区的一个实现

说说各个区域的作用？
程序计数器(线程私有)：一个指针，指向下一条指令的地址，由执行引擎读取下一条指令，内存非常小，
本地方法栈(线程私有)：登记native方法，执行引擎执行时加载本地方法库，非java语言的方法
方法区(线程共享):所有定义方法的信息，静态变量+常量+类信息(构造方法/接口定义)
java栈(线程私有):java线程执行方法的内存模型，一个线程对应一个栈，每个方法执行时会创建一个栈帧（局部变量，操作数栈，动态链接，方法出库等），无垃圾回收，线程结束就释放


Java 中会存在内存泄漏吗，简述一下？
长生命周期的对象引用一个短生命周期的对象

Java 类加载过程？
加载：在硬盘上查找并通过IO读入字节码文件
验证：1、文件格式验证（class文件的格式规范）2、元数据验证（语法分析）3、字节码验证（语义分析）4、符号引用验证
准备：为类变量分配内存并且设置初始化值的，都在方法区分配，只初始化静态字段，并赋值初始化值（final类型的直接代码定义的值），不是代码的值
解析：虚拟机将符号引用转化为直接引用的过程，主要针对类或接口、类方法、接口方法、方法类型、方法句柄、字段以及调用点限定符等符号进行
初始化：执行java程序，初始化用户代码写的值
使用：
卸载

描述一下 JVM 加载 Class 文件的原理机制?
什么是类加载器？
动态的把类加载到jvm，就是把class文件从磁盘读取到内存中
类加载器有哪些？
启动类加载器、扩展类加载器、系统类加载器、用户自定义加载器
类加载器双亲委派模型机制？
先委托父类加载器寻找目标类，找不到的情况下在自己路劲下查找病载入目标类

什么是tomcat类加载机制？
启动类->扩展类->应用程序类->common类加载器（/common/*）->1、catalina类加载器（/server/*）2、shared类加载器->Webapp类加载器->jsp类加载器
tomcat是一个web容器，解决的问题
部署多个服务时，保证每个服务的同一个类的不同版本是隔离的，
相同的类库版本可以共享
自己依赖的类库要跟应用程序的隔离
支持jsp修改不重启
如果使用默认加载机制，无法加载两个相同类库的不同版本
每个jsp对应唯一一个类加载器，当jsp修改后，就卸载这个类加载器，重新创建一个类加载器，重新加载jsp文件


什么是GC? 为什么要有 GC？
GC就是垃圾回收，如果没有GC,使用对象的时候会一直占用内存空间，造成内存溢出
简述一下Java 垃圾回收机制？
在新生代分配对象时，如果不够分配，先执行一次minorGC，执行之后如果内存还不够用，
就去老年代申请，如果老年代也没有足够的内存就执行majroGC,如果GC之后内存还是不够就包内存溢出。

如何判断一个对象是否存活？
通过根节点是否可达

垃圾回收的优点和原理，并考虑 2 种回收机制？
防止内存泄露，有效使用内存，编写程序不需要考虑垃圾回收
标记清除，标记整理

垃圾回收器的基本原理是什么？
侦测java程序的运行情况，当发现有些对象可以回收时，就会销毁这些对象，并且释放内存
Serial收集器:串行，单线程，新生代复制算法，老年代标记整理 单cpu场景，单线程效率高
ParNew收集器:串行，多线程，新生代复制算法，老年代标记整理
Parallel Scavenge收集器:关注吞吐量，高效率利用CPU,新生代复制算法，老年代标记整理  jdk1.8默认新生代
Serial Old收集器:CMS收集器的后备方案
Parallel Old收集器:Parallel Scavenge的老年代版本，关注吞吐量  jdk1.8默认老年代
CMS收集器：主要老年代使用，并发收集，低停顿，标记-清除算法实现，
初始标记：暂停用户线程
并发标记：跟用户线程同时开启，
重新标记：处理并发标记自己，影响初始标记的，停顿时间比初始标记时间长
并发清除：并发未标记的区域做清扫
缺点：会抢CPU资源，无法处理浮动垃圾，并发标记产生的垃圾，产生不连续的内存碎片
G1收集器：既满足低停顿，又有高吞吐量
G1讲堆划分为多个大小相等的独立区域（region),Eden,Survivor,old,Humongous
region 大小一致，数值是在 1M 到 32M 字节之间的一个 2 的幂值数，JVM 会尽量划分 2048 个左右、同等大小的 region
新生代和老年代不在物理隔阂，大对象直接进去Humongous，不用进老年代，避免fullGC
缺点：region 大小和大对象很难保证一致，这会导致空间的浪费；特别大的对象是可能占用超过一个 region 的。
并且，region 太小不合适，会令你在分配大对象时更难找到连续空间，这是一个长久存在的情况。
优点：1、并行并发2、分代收集，空间整合：整体看是标记整理，局部看是复制，可预测的停顿
1、初始标记：与常规的年轻代相关，停顿
2、并发标记：在整个堆上标记，
3、最终标记：停顿
4、筛选回收：停顿
在后台维护了一个优先列表，根据允许的收集时间，优先选择回收价值最大的Region
YongGC ,MixedGc回收所用Yong和部分Old

垃圾回收器可以马上回收内存吗？
不会马上回收，只有在必须回收时候才会进行回收，因为占用cpu开销特别大
有什么办法主动通知虚拟机进行垃圾回收？
System.gc()。Runtime.getRuntime().gc()
System.gc() 和 Runtime.gc() 会做些什么？
提示垃圾回收器进行垃圾回收，但是立刻回收还是延时回收取决于jvm

深拷贝和浅拷贝？
浅拷贝仅仅复制所拷贝的对象，而不复制它所引用的对象
把要复制的对象所引用的对象都复制了一遍


什么是分布式垃圾回收（DGC）？它是如何工作的？
RMI子系统实现基于引用计数的分布式垃圾回收（DGC),
远程对象回收时必须本地没有应用，并且远程服务也没有引用，
客户端创建远程引用时，会在服务端DGC调用dirty(),完成使用后调用clean()方法，
从dirty()开始是租期时间，到期之前必须调用dirty()来续约，如果在租期到期前不续约，则分布式垃圾回收认定客户端不再应用远程对象

串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
在 Java 中，对象什么时候可以被垃圾回收？
1、引用计数算法 2、可达性分析算法，GC roots是否可达
简述Minor GC 和 Major GC？
MinorGC新生代的GC，速度快，频率高
MajorGC老年代的GC,速度慢，频率低，一般至少会伴随一次minorGC,

Java 中垃圾收集的方法有哪些？
标记-清除：效率高，会产生大量不连续的碎片
标记-整理：先标记，然后让对象移动，再清楚，空间利用率高，效率慢
标记-复制：每次把存活对象复制到另一半，以空间换时间
分代收集：根据不同代采用不同算法

讲讲你理解的性能评价及测试指标？
停顿时间，吞吐量

常用的性能优化方式有哪些？
元空间大小，吞吐量大小，停顿时间参数，动态扩容增量，配置不同的收集器

什么是GC调优？
常见异步的手段有哪些？

CPU过高
（1）第一步  ， 用jps 查看java pid 
（2）第二步，显示线程列表 ps -mp 42 -o THREAD,tid,time
top -H -p 1920
jstat -gcutil 进程ID
（3）第三步，选择自己要看的线程id , 即tid。将其转换成16进制格式。当时选择的是tid 为211.  printf "%x\n" 211
（4）第四步  打印堆栈信息
jstack 进程号 | grep 线程号（16进制）
（5）第五步 从堆栈信息中定位问题代码
查看该VM参数
jinfo -flags pid
查看统计结果
jmap -heap pid
查看对象实例
jmap -histo 15178 | less

内存溢出
2.1 收集内存溢出Dump文件
jmap命令收集
jmap -dump:live,format=b,file=/opt/web_app/dump.hprof pid。
2.2 分析Dump文件
使用工具MAT(MemoryAnalyzer)进行分析
使用jvisualvm来分析dump文件：

jvisualvm是JDK自带的Java性能分析工具，在JDK的bin目录下，文件名就叫jvisualvm.exe