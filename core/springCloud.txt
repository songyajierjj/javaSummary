Eureka的自我保护特性主要用于减少在网络分区或者不稳定状况下的不一致性问题
默认情况下，如果Eureka Server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，
Eureka Server将会移除该实例。但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，
而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制

eureka 自我保护机制
Eureka在运行期间会统计心跳失败的比例，在15分钟内是否低于85%,如果出现了低于的情况，Eureka Server会将当前的实例注册信息保护起来，
同时提示一个警告，一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据。也就是不会注销任何微服务
1、Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。
2、Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。
3、当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中

Hystrix在底层使用了Spring提供的切面技术

SrpingCloud eureka
服务注册
服务提供者在启动时会将自己的信息注册到Eureka Server， Eureka Server收到信息后， 会将数据信息存储在一个双层结构的Map中，其中第一层的key是服务名，第二层的key是具体服务的实例名。

服务同步
如果有多个Eureka Server，一个服务提供者向其中一个Eureka Server注册了，这个Eureka Server会向集群内的其它Eureka Server转发这个服务提供者的注册信息，从而实现实现Eureka Server之间的服务同步

服务续约
在注册完成成后，服务提供者会维护一个心中持续发送信息给Eureka Server(注册中心)表示正常运行，以防止Eureka Server将该服务实例从服务列表中剔除。

服务下线
当服务实例正常关闭时，它会发送一个服务下线的消息给注册中心，注册中心收到信息后，会将该服务实例状态置为下线，并把该信息传播出去。

获取服务
当一个服务实例依赖另一个服务时，这时这个服务实例又充当了服务消费者，它会发送一个信息给注册中心, 请求获取注册的服务清单，注册中心会维护一份只读的服务清单来返回给服务消费者。

失效剔除
有时候，服务实例可能无法正常提供服务，而注册中心没有收到服务下线的信息。注册中心会创建一个定时任务，将超过一定时间没有服务续约消息的服务实例从服务清单中剔除。

自我保护
上面讲到失效剔除时，会将超过一定时间没有收到服务续约消息的实例从服务清单中剔除掉，在这中间还有一个逻辑。如果在运行期间，统计心跳成功的比例低于85%（心跳阈值），注册中心会将当前服务清单中的实例注册信息保护起来，让这些实例不会过期。但是在这种情况下，若服务实例出现问题，那么服务消费者可能会拿到实际已经不能正常运行的服务实例，就会出现调用失败的情况，所以客户端需要有容错机制，比如请求重试，或断路器等。
但是有一个定时任务默认每15分钟执行一次，会根据运行状况重新计算心跳阈值；但也可能不重新计算，这时，Eureka Server的自我保护状态会一直存在。

如果要关闭自我保护机制，可以将eureka.server.enable-self-preservation设置为false，以确保注册中心将不可用的服务实例及时剔除。


Srpingcloud Feign
Feign是一个声明式的Web服务客户端
Feign的一个关键机制就是使用了动态代理
首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理

接着你要是调用那个接口，本质就是会调用 Feign创建的动态代理，这是核心中的核心

Feign的动态代理会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址

最后针对这个地址，发起请求、解析响应

SrpingCloud ribbon
它的作用是负载均衡，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上
Ribbon的负载均衡默认使用的最经典的Round Robin轮询算法
首先Ribbon会从 Eureka Client里获取到对应的服务注册表，也就知道了所有的服务都部署在了哪些机器上，在监听哪些端口号。
然后Ribbon就可以使用默认的Round Robin算法，从中选择一台机器
Feign就会针对这台机器，构造并发起请求。

zuul 和 gateway
Zuul构建于 Servlet 2.5，兼容 3.x，使用的是阻塞式的 API，不支持长连接，比如 websockets。
Spring Cloud Gateway构建于 Spring 5+，基于 Spring Boot 2.x 响应式的、非阻塞式的 API。同时，它支持 websockets，和 Spring 框架紧密集成

zuul1.0 同步IO
Zuul 2.x 最大的改进就是基于 Netty Server 实现了异步 IO 来接入请求
同时基于 Netty Client 实现了到后端业务服务 API 的请求
这样就可以实现更高的性能、更低的延迟。

Hystrix
在底层使用了Spring提供的切面技术。
1、对通过第三方客户端库访问的依赖项（通常是通过网络）的延迟和故障进行保护和控制。
2、在复杂的分布式系统中阻止级联故障。
3、快速失败，快速恢复。
4、回退，尽可能优雅地降级。
5、启用近实时监控、警报和操作控制。
设计原则
防止任何单个依赖项耗尽所有容器（如Tomcat）用户线程。
甩掉包袱，快速失败而不是排队。
在任何可行的地方提供回退，以保护用户不受失败的影响。
使用隔离技术（如隔离板、泳道和断路器模式）来限制任何一个依赖项的影响。
通过近实时的度量、监视和警报来优化发现时间。
通过配置的低延迟传播来优化恢复时间。
支持对Hystrix的大多数方面的动态属性更改，允许使用低延迟反馈循环进行实时操作修改。
避免在整个依赖客户端执行中出现故障，而不仅仅是在网络流量中

资源隔离
Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩.

熔断器
服务的健康状况 = 请求失败数 / 请求总数. 
熔断器开关由关闭到打开的状态转换是通过当前服务健康状况和设定阈值比较决定的
1、当熔断器开关关闭时, 请求被允许通过熔断器. 如果当前健康状况高于设定阈值, 
开关继续保持关闭. 如果当前健康状况低于设定阈值, 开关则切换为打开状态.
2、当熔断器开关打开时, 请求被禁止通过.
3、当熔断器开关处于打开状态, 经过一段时间后, 熔断器会自动进入半开状态, 这时熔断器只允许一个请求通过. 
当该请求调用成功时, 熔断器恢复到关闭状态. 若该请求失败, 熔断器继续保持打开状态, 接下来的请求被禁止通过.

命令模式
构建Hystrix的Command对象, 调用执行方法.
Hystrix检查当前服务的熔断器开关是否开启, 若开启, 则执行降级服务getFallback方法.
若熔断器开关关闭, 则Hystrix检查当前服务的线程池是否能接收新的请求, 若超过线程池已满, 则执行降级服务getFallback方法.
若线程池接受请求, 则Hystrix开始执行服务调用具体逻辑run方法.
若服务执行失败, 则执行降级服务getFallback方法, 并将执行结果上报Metrics更新服务健康状况.
若服务执行超时, 则执行降级服务getFallback方法, 并将执行结果上报Metrics更新服务健康状况.
若服务执行成功, 返回正常结果.
若服务降级方法getFallback执行成功, 则返回降级结果.
若服务降级方法getFallback执行失败, 则抛出异常

服务雪崩的应对策略
1、流量控制 （网关限流、用户交互限流、关闭重试）
2、改进缓存模式
3、服务自动扩容
4、服务调用者降级服务