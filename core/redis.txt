redis数据结构有哪些？
string,list,set,zset,hash

Redis缓存穿透，缓存雪崩？
缓存穿透：恶意用户模拟请求许多缓存中不存在的数据，导致请求落库，造成数据库异常
解决方案：1使用互斥锁排队 2、接口限流、熔断、降级  3、布隆过滤器
缓存雪崩，是指在某一个时间段，缓存集中过期失效

接口限流、熔断、降级方案

如何使用Redis来实现分布式锁？
redis.setnx expire

Redis的并发竞争问题如何解决？
利用redis自带的incr命令
使用乐观锁的方式
在客户端加锁

Redis持久化的几种方式，优缺点是什么，怎么实现的？
RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储
save <seconds> <changes> 每隔多少秒 有多少个操作
AOF 记录日志 ，增量持久化
1、no，不调用fsync，即由操作系统自己决定何时刷新数据，这种速度很快。
2、always，每次写入追加日志后调用fsync，速度慢，但是最安全。
3、everysec，每一秒调用fsync，折中方案。

RDB存在哪些优势呢？
1). 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。
比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。
2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。
3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。
4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。

RDB又存在哪些劣势呢？
1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。
2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。

AOF的优势有哪些呢？
1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。
事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。
而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。
2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。
然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。
3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，
同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。
4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。

AOF的劣势有哪些呢？
1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。

二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），
还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。

Redis的缓存失效策略？
过期键删除策略:1、定期随机删除 2、惰性删除
内存淘汰机制：
volatile-lru ：在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把 redis 既当缓存，又做持久化存储的时候才用
allkeys-lru ： 移除最近最少使用的key （推荐）
volatile-random ： 在设置了过期时间的键空间中，随机移除一个键，不推荐
allkeys-random ： 直接在键空间中随机移除一个键
volatile-ttl ： 在设置了过期时间的键空间中，有更早过期时间的key优先移除 不推荐
noeviction ： 不做过键处理，只返回一个写操作错误。 不推荐


Redis集群，高可用，原理？
(1).Redis 集群的分片特征在于将键空间分拆了16384个槽位，每一个节点负责其中一些槽位。 
(2).Redis提供一定程度的可用性,可以在某个节点宕机或者不可达的情况下继续处理命令. 
(3).Redis 集群中不存在中心(central)节点或者代理(proxy)节点， 集群的其中一个主要设计目标是达到线性可扩展性(linear scalability)

 集群的使用公式HASH_SLOT=CRC16(key) mod 16384 计算key属于哪个槽

redis队列应用场景？
lpush,lpop,rpush,rpop

分布式使用场景（储存session）？
session,分布式锁

Redis主要有哪些功能？

Redis是单进程单线程的？
单线程

Redis为什么是单线程的？
内存数据库，
单线程减少上下文切换，
核心是基于非阻塞的 IO 多路复用机制
redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型
文件事件处理器的结构包含 4 个部分：
多个 socket
IO 多路复用程序
文件事件分派器
事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，
会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理

其它开源软件采用的模型

使用Redis的优势？

Redis单点吞吐量
qps 10万/秒 tps 8万/秒

Redis相比memcached有哪些优势？
redis 支持复杂的数据结构
redis 原生支持集群模式
redis 支持持久化
redis 单线程性能更好


Redis集群方案应该怎么做？都有哪些方案？
客户端分片
codis
原生集群

Redis读写分离模型

Redis常见性能问题和解决方案？

Redis支持的Java客户端都有哪些？官方推荐用哪个？
Redisson,Jedis，lettuce

Redis集群的主从复制模型是怎样的？

Redis集群会有写操作丢失吗？为什么？

Redis集群之间是如何复制的？
①从数据库向主数据库发送sync(数据同步)命令。
②主数据库接收同步命令后，会保存快照，创建一个RDB文件。
③当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。
④主数据库将缓冲区的所有写命令发给从服务器执行。
⑤以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。

Redis如何做内存优化？

Redis有哪些适合的场景？

Redis缓存一致性问题
1先更新数据库再更新缓存 （不可行）
线程A更新了数据库
线程B更新了数据库
线程B更新了缓存
线程A更新了缓存
正确结果应为缓存A数据，但是因为网络原因或者其他原因，导致缓存了B数据，出现脏数据问题
2先删除缓存再更新数据库
出现问题
请求A进行写操作，删除缓存
请求B查询发现缓存不存在
请求B去数据库查询得到旧值
请求B将旧值写入缓存
请求A将新值写入数据库
上述情景则会导致缓存不一致问题出现
使用延时双删策略
先删除再更新然后延时一段时间再更新数据库
3先更新数据库，再删缓存
缓存刚好失效
请求A查询数据库，得一个旧值
请求B将新值写入数据库
请求B删除缓存
请求A将查到的旧值写入缓存

redis内存消耗
1.自身内存：redis自身运行所消耗的内存，一般很小。

2.对象内存：这是redis消耗内存最大的一块，存储着用户所有的数据，每次存入key-value的键值对，暂时可以简单的理解为sizeof(key+value)的内存大小消耗。

3.缓冲内存：缓冲内存主要包括：客户端缓冲、复制积压缓冲区、AOF缓冲区。
客户端缓冲：是指客户端连接redis之后，输入或者输出数据的缓冲区，其中输出缓冲可以通过配置参数参数client-output-buffer-limit控制。
复制积压缓冲区：一个可重用的固定大小缓冲区用于实现部分复制功能，根据repl-backlog-size参数控制，默认1MB。对
于复制积压缓冲区整个主节点只有一个，所有的从节点共享此缓冲区，因此可以设置较大的缓冲区空间，如100MB，这部分内存投入是有价值的，可以有效避免全量复制。
AOF缓冲区：这部分空间用于在Redis重写期间保存最近的写入命令，AOF缓冲区空间消耗用户无法控制，消耗的内存取决于AOF重写时间和写入命令量，这部分空间占用通常很小。

4.内存碎片：redis的内存分配器为了更好地管理和重复利用内存，分配内存策略一般采用固定范围的内存块进行分配，
如8byte，16byte……4kb，8kb……4mb…….每一个数据块的大小是固定的，如果当前输入的key-value实际占用的大小是6kb，
那么redis可能申请一个8kb的内存块来存储这一份数据，那么该8kb内存块对于服务器来讲已经分配出去，不会再让其他的数据占用，
但是实际上此次存入数据的时候，有2kb的内存是没有使用到的，所以这个插入操作产生了2kb的内存碎片。当然，这是所有内存分配器无法避免的通病，但是可以优化。

1.使用更好的内存分配器：
2.不要频繁的对已存在的键做append、setrange等更新操作：
3.大量的过期键：
4.数据对齐：
5.重启redis服务：

减少redis使用的内存：
1.使用共享对象池
2.尽可能让hash表以ziplist编码存储
3.控制键的数量
4.缩短key-value的长度


1、性能
都比较高，性能对我们来说应该都不是瓶颈
总体来讲，TPS方面redis和memcache差不多，要大于mongodb

2、操作的便利性
memcache数据结构单一
redis丰富一些，数据操作方面，redis更好一些，较少的网络IO次数
mongodb支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富

3、内存空间的大小和数据量的大小
redis在2.0版本后增加了自己的VM特性，突破物理内存的限制；可以对key value设置过期时间（类似memcache）
memcache可以修改最大可用内存,采用LRU算法
mongoDB适合大数据量的存储，依赖操作系统VM做内存管理，吃内存也比较厉害，服务不要和别的服务在一起

4、可用性（单点问题）
对于单点问题，
redis，依赖客户端来实现分布式读写；主从复制时，每次从节点重新连接主节点都要依赖整个快照,无增量复制，因性能和效率问题，
所以单点问题比较复杂；不支持自动sharding,需要依赖程序设定一致hash 机制。
一种替代方案是，不用redis本身的复制机制，采用自己做主动复制（多份存储），或者改成增量复制的方式（需要自己实现），一致性问题和性能的权衡
Memcache本身没有数据冗余机制，也没必要；对于故障预防，采用依赖成熟的hash或者环状的算法，解决单点故障引起的抖动问题。
mongoDB支持master-slave,replicaset（内部采用paxos选举算法，自动故障恢复）,auto sharding机制，对客户端屏蔽了故障转移和切分机制。


5、可靠性（持久化）
对于数据持久化和数据恢复，
redis支持（快照、AOF）：依赖快照进行持久化，aof增强了可靠性的同时，对性能有所影响
memcache不支持，通常用在做缓存,提升性能；
MongoDB从1.8版本开始采用binlog方式支持持久化的可靠性

6、数据一致性（事务支持）
Memcache 在并发场景下，用cas保证一致性
redis事务支持比较弱，只能保证事务中的每个操作连续执行
mongoDB不支持事务

7、数据分析
mongoDB内置了数据分析的功能(mapreduce),其他不支持

8、应用场景
redis：数据量较小的更性能操作和运算上
memcache：用于在动态系统中减少数据库负载，提升性能;做缓存，提高性能（适合读多写少，对于数据量比较大，可以采用sharding）
MongoDB:主要解决海量数据的访问效率问题   