https://cloud.tencent.com/developer/article/1469131

interactive_timeout = 1800 交互式链接超时时间（通过mysql客户端）
wait_timeout = 1800 非交互式链接超时时间（通过jdbc链接）

MySQL 有哪些存储引擎啊？都有什么区别？
MyIsam
InnoDB 支持事务，行级锁，外键
MyISAM 不支持事务，表级锁，保持表的行数

innoDB行锁是通过给索引上的索引项加锁来实现的

Float、Decimal 存储金额的区别？
Float只保存6位，

Datetime、Timestamp 存储时间的区别？
Timestamp转化为UTC存储，查询时又反转，Datetime不变
存储范围不一致，Timestamp只能存储到1970-2038年，Datetime存储1000到9999

Char、Varchar、Varbinary 存储字符的区别？
char使用固定长度的空间进行存储，经常改变的值，char优于varchar，原因是固定长度的行不容易产生碎片，自动去空格
varchar保存可变长度的字符串，使用额外的一个或两个字节存储字符串长度
Varbinary保存的是字节

对比一下B+树索引和 Hash索引？

MySQL索引类型有？
HASH,BTRee


如何管理 MySQL索引？
对Explain参数及重要参数的理解？
1、ID:是否有子查询，值越大优先级越高
2、select_type:查询类型
simple:简单的select查询,查询中不包含子查询或union查询
primary:查询中若包含任何复杂的子部分,最外层查询则被标记为primary
subquery 在select 或where 列表中包含了子查询
derived 在from列表中包含的子查询被标记为derived,mysql会递归这些子查询,把结果放在临时表里
union 做第二个select出现在union之后,则被标记为union,若union包含在from子句的子查询中,外层select将被标记为derived
union result 从union表获取结果的select
3、table:显示一行的数据时关于哪张表的
4、type:从最好到最差依次是:system>const>eq_ref>ref>range>index>All
system:表只有一行记录,这是const类型的特例,平时不会出现
const:表示通过索引一次就找到了,const即常量,它用于比较primary key或unique索引,因为只匹配一行数据,所以效率很快,如将主键置于where条件中,mysql就能将该查询转换为一个常量
eq_ref:唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配,常见于主键或唯一索引扫描
ref:非唯一性索引扫描,返回匹配某个单独值的行,它可能会找到多个符合条件的行,所以他应该属于查找和扫描的混合体
range:只检索给定范围的行,使用一个索引来选择行,如where语句中出现了between,<,>,in等查询,
这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。
index:index类型只遍历索引树,这通常比All快,因为索引文件通常比数据文件小,index是从索引中读取,all从硬盘中读取
all:全表扫描,是最差的一种查询类型
5、possible_keys:显示可能应用在这张表中的索引,一个或多个,查询到的索引不一定是真正被用到的
6、key:实际使用的索引,如果为null,则没有使用索引,因此会出现possible_keys列有可能被用到的索引,但是key列为null,表示实际没用索引。
7、key_len:表示索引中使用的字节数,而通过该列计算查询中使用的 索引长度,在不损失精确性的情况下,长度越短越好,
key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即,key_len是根据表定义计算而得么不是通过表内检索出的
8、ref显示索引的哪一列被使用了,如果可能的话是一个常数,哪些列或常量被用于查找索引列上的值
9、rows根据表统计信息及索引选用情况,大只估算出找到所需的记录所需要读取的行数
10、Extra
Using filesort:说明mysql会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取,mysql中无法利用索引完成的排序操作称为"文件排序"
Using temporary :使用了临时表保存中间结果,mysql在对查询结果排序时使用临时表,常见于order by和分组查询group by
Using index:表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。如果同时出现using where，
表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。 其中的覆盖索引含义是所查询的列是和建立的索引字段和个数是一一对应的
Using where:表明使用了where过滤
Using join buffer:表明使用了连接缓存,如在查询的时候会有多次join,则可能会产生临时表
impossible where:表示where子句的值总是false,不能用来获取任何元祖


索引利弊是什么及索引分类？
增加存储空间，更新增加IO消耗
种类：普通索引，唯一索引，主键索引，组合索引，全文索引

(1)索引并非越多越好，大量的索引不仅占用磁盘空间，而且还会影响insert,delete,update等语句的性能
(2)避免对经常更新的表做更多的索引，并且索引中的列尽可能少；对经常用于查询的字段创建索引，避免添加不必要的索引
(3)数据量少的表尽量不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果
(4)在条件表达式中经常用到不同值较多的列上创建索引，在不同值很少的列上不要建立索引。比如性别字段只有“男”“女”俩个值，就无需建立索引。如果建立了索引不但不会提升效率，反而严重减低数据的更新速度
(5)在频繁进行排序或者分组的列上建立索引，如果排序的列有多个，可以在这些列上建立联合索引。

聚簇索引和非聚簇索引的区别？
聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
非聚簇索引：索引与数据分开存储

讲讲索引的分类？你知道哪些
从物理存储角度: 聚簇索引和非聚簇索引
从数据结构角度: B+树索引、hash索引、FULLTEXT索引、R-Tree索引
从逻辑角度:
主键索引：主键索引是一种特殊的唯一索引，不允许有空值
普通索引或者单列索引
多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合
唯一索引或者非唯一索引
空间索引：空间索引是对空间数据类型的字段建立的索引，
MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。

如何避免回表查询?什么是索引覆盖?
在索引上就能找到结果，就不用回表去查询
覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引不存储索引列的值，所以mysql只能用B+ tree索引做覆盖索引

如果数据是唯一的，建立唯一索引还是普通索引
唯一索引影响插入速度，但是有效提高查询速度
为什么唯一索引的插入速度比不上普通索引？为什么唯一索引的查找速度比普通索引快？
在进行非聚簇索引的插入时，先判断插入的索引页是否在内存中。如果在，则直接插入；
如果不在，则先放入Insert Buffer 中，然后再以一定频率和情况进行Insert Buffer和原数据页合并(merge)操作。
这么做的优点:能将多个插入合并到一个操作中，就大大提高了非聚簇索引的插入性能。
InnoDB 从 1.0.x 版本开始引入了 Change Buffer，可以算是对 Insert Buffer 的升级。
从这个版本开始，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。
唯一索引的插入比普通索引慢的原因就是:唯一索引无法利用Change Buffer普通索引可以利用Change Buffer
为什么唯一索引的更新不使用 Change Buffer？
因为唯一索引为了保证唯一性，需要将数据页加载进内存才能判断是否违反唯一性约束。
但是，既然数据页都加载到内存了，还不如直接更新内存中的数据页，没有必要再使用Change Buffer。
普通索引在找到满足条件的第一条记录后，还需要判断下一条记录，直到第一个不满足条件的记录出现。
唯一索引在找到满足条件的第一条记录后，直接返回，不用判断下一条记录了。

mysql索引是什么结构的？用红黑树可以么?
B+ Tree。
AVL树和红黑树基本都是存储在内存中才会使用的数据结构。在大规模数据数据存储的时候，显然不能将全部数据全部加载进内存，因此如果采用红黑树，就会造成频繁IO，效率低下。

6、mysql某表建了多个单索引，查询多个条件时如何走索引的？
Mysql在优化器中有一个优化器称为Range 优化器，负责进行范围查询的优化！
那么该优化器计算执行成本有两种方式index dive与index statistics。
它们是MySQL优化器对开销代价的估算方法，前者统计速度慢但是能得到精准的值，后者统计速度快但是数据未必精准。
对于index dive:
计算成本的方式为
COST = CPU COST + IO COST
其中CPU COST指的是处理返回记录所花的开销。而IO COST指的是读取页面的开销。
mysql会对每种索引的执行情况，进行上述成本计算，最后以成本小的方式进行执行。
但是呢，在某些情况下mysql执行index dive的成本太大。因此优化器会选择以index statistics方式进行估算成本。具体如下：SHOW INDEX FROM tbl_name [FROM db_name]

B+tree 如何进行优化？索引遵循哪些原则？

索引与锁有什么关系？
InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁

还有什么其他的索引类型，各自索引有哪些优缺点？

谈谈对Innodb事务的理解？
A原子性 C一致性 I隔离性 D持久性
ACD通过redo log(重做日志)和(Undo log)实现，隔离性通过锁来实现
Redo log 物理日志
重做日志用来实现事务的持久性，即D特性。它由两部分组成：
①内存中的重做日志缓冲
②重做日志文件
Undo log 逻辑日志
实现事务回滚
实现mvcc

说说数据库事务特点及潜在问题？

什么是MySQL隔离级别？
读未提交  脏读，不可重复读，幻读
读已提交  不可重复读，幻读
可重复读  幻读
串行化

脏读：所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。

不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。
也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。

幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。
也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。

1、事务隔离级别为读提交时，写数据只会锁住相应的行
2、事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，
更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。
、事务隔离级别为串行化时，读写数据都会锁住整张表


有多少种事务失效的场景，如何解决？
Transactional的异常控制，默认是Check Exception 不回滚，unCheck Exception回滚

一致性非锁定读和一致性锁定读是什么？
一致性非锁定读指的是：要读取的行被加了X锁（排它锁），这时候读取操作不会等待行上锁的释放，而是会读取行的一个快照数据
行记录可能有多个版本
在RC下读取的是最新的一份快照数据，在RR下读取的是事务开始的数据版本
一致性锁定读在事务读取时就把记录锁住 for update, lock in share mode


表级锁分为读锁和写锁
读锁：LOCK TABLE table_name [ AS alias_name ] READ
申请前提是没有其它线程对该表使用写锁，申请之后其它线程可以执行读操作，不能执行写操作
写锁：LOCK TABLE table_name [AS alias_name] [ LOW_PRIORITY ] WRITE
可以指定优先级，

行级锁：锁粒度最细的一种锁，减少数据库操作的冲突，分为共享锁和排他锁
共享锁(S LOCK): SELECT ...LOCK IN SHARE MODE;
mysql会对查询结果的每行都加共享锁，没有其他线程对查询结果的任何一行使用排他锁时，可以成功申请共享锁，
排他锁(X LOCK)：SELECT ...LOCK FOR UPDATE;
mysql会对查询结果的每行都加排他锁，没有其他线程对查询结果的任何一行使用排他锁时，可以成功申请排他锁，
行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大

死锁：死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象，若无外力作用,它们都将无法推进下去.
产生条件：
互斥条件-指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放
请求和保持条件-指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放
不可剥夺条件-指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放
环路等待条件-指在发生死锁时，必然存在一个进程――资源的环形链，即进程集合{P0，P1，P2，・・・，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源

死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，
这是一种保证系统不进入死锁状态的动态策略。 如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的。
有序资源分配法
1、对它所必须使用的而且属于同一类的所有资源，必须一次申请完；
2、在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。
银行家算法

Innodb如何解决幻读？
多版本并发控制（MVCC)
每一行都冗余了两个字段，一个是行的创建版本，一个是行的删除版本
版本号存在information_schema.INNODB_TRX表中
版本号（trx_id）随着每次事务开启自增
每次取的时候取创建版本小于当前的版本，删除版本大于当前的版本

死锁及监控是什么？
自增长与锁：轻量级互斥量的自增长实现机制
锁的算法，锁问题，锁升级是什么？

乐观锁的线程如何做失败补偿？
1、消息队列处理
2、aop(自定义异常，更新失败抛出异常，重试）

谈谈MySQL的锁并发？
查询优化的基本思路是什么？
explain查看执行计划

说说MySQL读写分离、分库分表？
表结构对性能有什么影响?
浅谈索引优化？
说说Sql优化的几点原则？
MySQL表设计及规范？
说说MySQL几种存储引擎应用场景？
MySQL常用优化方式有哪些？

MySQL常用监控？
指标分类	指标名称	指标说明
性能类指标	QPS	数据库每秒处理的请求数量
		TPS	数据库每秒处理的事务数量
		并发数	数据库实例当前并行处理的会话数量
		连接数	连接到数据库会话的数量
		缓存命中率	查询命中缓存的比例
高可用指标	可用性	数据库是否可以正常对外服务
		阻塞	当前阻塞的会话数
		慢查询	慢查询情况
		主从延迟	主从延迟时间
		主从状态	主从链路是否正常
		死锁	查看死锁信息

MySQL瓶颈分析？

mysql的两个机制
MySQL支持单向、双向、链式级联、异步复制，5.5版本之后加入的半同步复制，5.6版本之后的GTID复制，MySQL5.7的多源复制、并行复制、loss-less复制
半同步复制，用来解决主库数据丢失问题 通过从库ack确认
并行复制，解决同步延时问题 从库开启多个并行读取relay 
log中不同库的日志，并行重放不同库的日志，库级别的并行
异步复制是MySQL默认的复制方式，主库写入binlog日志后即可成功返回客户端，无须等待binlog日志传递给从库的过程，但是一旦主库宕机，就有可能出现丢失数据的情况
半同步复制提升了主从之间数据的一致性，让复制更加安全可靠
AFTER_COMMIT 5.6版本的默认值，主库将每个事务写入binlog，并传递给从库，刷新到中继日志中，同时主库提交事务。
之后主库开始等待从库的反馈，只有收到从库的回复之后，master才将commit OK的结果反馈给客户端 
AFTER_SYNC 5.7版本新增，也是默认的半同步复制方式。主库将每个事务写入binlog并传递给从库，刷新到中继日志中，
主库开始等待从库的反馈，接收到从库的回复之后，再提交事务并且返回commit OK结果给客户端。
