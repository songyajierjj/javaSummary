并发编程：

什么是多线程并发和并行？ 
并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生

什么是线程安全问题？ 
多个线程在操作同一个共享变量的时候，预期结果和实际结果不一致。

什么是共享变量的内存可见性问题？ 
每个线程都有自己的私有内存空间（栈），线程启动后会把共享变量的值从共享内存拷贝一份到私有内存，并且再修改之后再push到共享内存，

什么是Java中原子性操作？
不会被线程调度机制打断的操作，一旦开始就不会被打断，一直到结束。

什么是Java中的CAS操作,AtomicLong实现原理？
比较并交换，内存值V,预期原值A,新值B,只有A=V的时候，才将V设置为B

什么是Java指令重排序？
在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序 分三种 编译优化的重排序，指令级并行的重排序，内存系统的重排序

Java中Synchronized关键字的内存语义是什么？
synchronized 具有使每个线程依次排队操作共享变量的功能 原子性（只能被一个线程访问），可见性，有序性（只能被一个线程访问）

Java中Volatile关键字的内存语义是什么？
写的时候会把值刷新到主内存，读的时候把本地缓存清空，从主内存读取共享变量的值 可见性 有序性

什么是伪共享,为何会出现，以及如何避免？
当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享

什么是可重入锁、乐观锁、悲观锁、公平锁、非公平锁、独占锁、共享锁？
可重入锁 可以多次获取同一把锁
乐观锁 不锁住对象
悲观锁 锁住对象
公平锁 需要排队
非公平锁 不需要排队
独占锁 每次只能由一个线程占用
共享锁 可以被多个线程共有

讲讲ThreadLocal 的实现原理？ThreadLocal 作为变量的线程隔离方式，其内部是如何做的？
Thread对象有一个ThreadLocalMap对象，key就是ThreadLocal,value可以任意值，以空间换时间，每个线程独自拥有一个变量，是隔离的

说说InheritableThreadLocal 的实现原理？
InheritableThreadLocal 是如何弥补 ThreadLocal 不支持继承的特性？

CyclicBarrier内部的实现与 CountDownLatch 有何不同？
CyclicBarrier主要基于ReentrantLock 以及 Condition 的共享唤醒线程，parties，count，每次调用await()方法时count-1，如果不等于0，
调用condition.await()方法阻塞等待，如果等于0，则调用condition.signalAll()方法唤醒所有线程执行，同时count = parties,可重用
CountDownLatch主要基于AQS实现，初始化state，每次调用coundDown()，state减1，直到减为0时，调用await()唤醒所有线程。

随机数生成器 Random 类如何使用 CAS 算法保证多线程下新种子的唯一性？
通过AtomicLong的compareAndSet来实现旧的种子跟新的种子的切换，来保证新种子的唯一性

ThreadLocalRandom 是如何利用 ThreadLocal 的原理来解决 Random 的局限性？
RANDOM是CAS操作，多个线程公用一个种子，会降低并发性能，ThreadLocalRandom实现了每个线程有自己单独的种子，提高性能

Spring 框架中如何使用 ThreadLocal 实现 request scope 作用域 Bean？

并发包中锁的实现底层（对AQS的理解）？

讲讲独占锁 ReentrantLock 原理？
CAS+CLH队列来实现,state从0开始


谈谈读写锁 ReentrantReadWriteLock 原理？
state是int类型，共32位，
读锁用高16位，表示持有读锁的线程数（sharedCount）
写锁用低16位，表示写锁的重入次数 （exclusiveCount）
状态值为 0 表示锁空闲，读锁可连续获取多个，写锁只能在没有任何读写时才能获取，写锁的线程可获取当前线程的读锁，读锁获取时如果有写锁在队列等待，该读锁也必须入队。

StampedLock 锁原理的理解？

谈下对基于链表的非阻塞无界队列 ConcurrentLinkedQueue 原理的理解？
tail,head
入队时有两种操作：
1、如果tail.next为空，将入队节点设置成尾节点的下一个节点
2、如果tail的next不为空，将入队节点设置成tail节点
ConcurrentLinkedQueue 内部是如何使用 CAS 非阻塞算法来保证多线程下入队出队操作的线程安全？

基于链表的阻塞队列 LinkedBlockingQueue 原理。
基于ReentrantLock 实现，定义了两个ReentrantLock对象一个takeLock，一个putLock，两个condition配合takeLock,putLock
阻塞队列LinkedBlockingQueue 内部是如何使用两个独占锁 ReentrantLock 以及对应的条件变量保证多线程先入队出队操作的线程安全？

分析下JUC 中倒数计数器 CountDownLatch 的使用与原理？
基于AQS实现共享锁实现，初始化state，调用countdown时候，cas方法state减1，调用await()阻塞等待
一个或者多个线程等待一组线程执行完毕，必须等所有运动员跑到终点才可以发布成绩（可以设置超时时间）
CountDownLatch 与线程的 Join 方法区别是什么？
thread.join() 方法必须等thread 执行完毕，才能向下执行
CountDownLatch 则只要计数器为0，就可以继续执行

讲讲对JUC 中回环屏障 CyclicBarrier 的使用？
让一组线程等待某个事件发生，才能继续执行，所有运动员等待枪响才可以开始跑步，

CyclicBarrier内部的实现与 CountDownLatch 有何不同？
CountDownLath让等待的线程不阻塞，CyclicBarrier让线程阻塞，可重用

Semaphore 的内部实现是怎样的？
限定线程并发数量，基于AQS实现，有公平模式和非公平模式

并发组件CopyOnWriteArrayList 是如何通过写时拷贝实现并发安全的 List？
写的时候把数据元素copy一份，通过ReetrantLock加锁，如果读取的时候读的是老数据，写入之后把list数组地址指向新的地址

同步与异步？阻塞与非阻塞？

1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。
2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）
3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者

1、并发编程三要素？
原子性、可见性、有序性

2、实现可见性的方法有哪些？
锁
volatile

3、多线程的价值？
充分利用多核cpu的优势，效率高

3、创建线程的有哪些方式？
Threa,Runnable,Callable+Future

4.创建线程的三种方式的对比？

5、线程的状态流转图

6.Java线程具有五中基本状态

7.什么是线程池？有哪几种创建方式？

8.四种线程池的创建：

9.线程池的优点？

10.常用的并发工具类有哪些？

11.CyclicBarrier和CountDownLatch的区别

12.synchronized的作用？

13.volatile关键字的作用

14.什么是CAS

15. CAS的问题

16.什么是Future？

17.什么是AQS

18. AQS支持两种同步方式：

19.ReadWriteLock是什么

20.FutureTask是什么

21.synchronized和ReentrantLock的区别

22.什么是乐观锁和悲观锁

23.线程B怎么知道线程A修改了变量

24.synchronized、volatile、CAS比较

25.sleep方法和wait方法有什么区别?

26.ThreadLocal是什么？有什么用？

27.为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用

28.多线程同步有哪几种方法？

29.线程的调度策略

30.ConcurrentHashMap的并发度是什么

31.Linux环境下如何查找哪个线程使用CPU最长

32.Java死锁以及如何避免？

33.死锁的原因

34.怎么唤醒一个阻塞的线程

35.不可变对象对多线程有什么帮助

36.什么是多线程的上下文切换

37.如果你提交任务时，线程池队列已满，这时会发生什么

38.Java中用到的线程调度算法是什么

39.什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？

40.什么是自旋

41.Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？

42.单例模式的线程安全性

43.Semaphore有什么作用

44.Executors类是什么？

45.线程类的构造方法、静态块是被哪个线程调用的

46.同步方法和同步块，哪个是更好的选择?

47.Java线程数过多会造成什么异常？


JVM

Java 内存分配？
程序计数器，虚拟机栈，本地方法栈，堆，方法区
Java 堆的结构是什么样子的？
新生代（Eden,from/to） 1/3,老年代 2/3

什么是堆中的永久代（Perm Gen space）?
方法区，存储class、运行时常量池、字段、方法、代码、JIT代码等，是一个规范，规定了这个里面要存储什么东西
永久代是方法区的一个实现


说说各个区域的作用？
程序计数器(线程私有)：一个指针，指向下一条指令的地址，由执行引擎读取下一条指令，内存非常小，
本地方法栈(线程私有)：登记native方法，执行引擎执行时加载本地方法库，非java语言的方法
方法区(线程共享):所有定义方法的信息，静态变量+常量+类信息(构造方法/接口定义)
java栈(线程私有):java线程执行方法的内存模型，一个线程对应一个栈，每个方法执行时会创建一个栈帧（局部变量，操作数栈，动态链接，方法出库等），无垃圾回收，线程结束就释放


Java 中会存在内存泄漏吗，简述一下？
长生命周期的对象引用一个短生命周期的对象

Java 类加载过程？
加载：在硬盘上查找并通过IO读入字节码文件
验证：1、文件格式验证（class文件的格式规范）2、元数据验证（语法分析）3、字节码验证（语义分析）4、符号引用验证
准备：为类变量分配内存并且设置初始化值的，都在方法区分配，只初始化静态字段，并赋值初始化值（final类型的直接代码定义的值），不是代码的值
解析：虚拟机将符号引用转化为直接引用的过程，主要针对类或接口、类方法、接口方法、方法类型、方法句柄、字段以及调用点限定符等符号进行
初始化：执行java程序，初始化用户代码写的值
使用：
卸载

描述一下 JVM 加载 Class 文件的原理机制?
什么是类加载器？
动态的把类加载到jvm，就是把class文件从磁盘读取到内存中
类加载器有哪些？
启动类加载器、扩展类加载器、系统类加载器、用户自定义加载器
类加载器双亲委派模型机制？
先委托父类加载器寻找目标类，找不到的情况下在自己路劲下查找病载入目标类

什么是tomcat类加载机制？
启动类->扩展类->应用程序类->common类加载器（/common/*）->1、catalina类加载器（/server/*）2、shared类加载器->Webapp类加载器->jsp类加载器
tomcat是一个web容器，解决的问题
部署多个服务时，保证每个服务的同一个类的不同版本是隔离的，
相同的类库版本可以共享
自己依赖的类库要跟应用程序的隔离
支持jsp修改不重启
如果使用默认加载机制，无法加载两个相同类库的不同版本
每个jsp对应唯一一个类加载器，当jsp修改后，就卸载这个类加载器，重新创建一个类加载器，重新加载jsp文件


什么是GC? 为什么要有 GC？
GC就是垃圾回收，如果没有GC,使用对象的时候会一直占用内存空间，造成内存溢出
简述一下Java 垃圾回收机制？
在新生代分配对象时，如果不够分配，先执行一次minorGC，执行之后如果内存还不够用，
就去老年代申请，如果老年代也没有足够的内存就执行majroGC,如果GC之后内存还是不够就包内存溢出。

如何判断一个对象是否存活？
通过根节点是否可达

垃圾回收的优点和原理，并考虑 2 种回收机制？
防止内存泄露，有效使用内存，编写程序不需要考虑垃圾回收
标记清除，标记整理

垃圾回收器的基本原理是什么？
侦测java程序的运行情况，当发现有些对象可以回收时，就会销毁这些对象，并且释放内存
Serial收集器:串行，单线程，新生代复制算法，老年代标记整理
ParNew收集器:串行，多线程，新生代复制算法，老年代标记整理
Parallel Scavenge收集器:关注吞吐量，高效率利用CPU,新生代复制算法，老年代标记整理
Serial Old收集器:CMS收集器的后备方案
Parallel Old收集器:Parallel Scavenge的老年代版本，关注吞吐量
CMS收集器：主要老年代使用，并发收集，低停顿，标记-清除算法实现，
初始标记：暂停用户线程
并发标记：跟用户线程同时开启，
重新标记：处理并发标记自己，影响初始标记的，停顿时间比初始标记时间长
并发清除：并发未标记的区域做清扫
缺点：会抢CPU资源，无法处理浮动垃圾，并发标记产生的垃圾，产生不连续的内存碎片
G1收集器：既满足低停顿，又有高吞吐量
G1讲堆划分为多个大小相等的独立区域（region),Eden,Survivor,old,Humongous
新生代和老年代不在物理隔阂，大对象直接进去Humongous，不用进老年代，避免fullGC
优点：1、并行并发2、分代收集，空间整合：整体看是标记整理，局部看是复制，可预测的停顿
1、初始标记：与常规的年轻代相关，停顿
2、并发标记：在整个堆上标记，
3、最终标记：停顿
4、筛选回收：停顿
在后台维护了一个优先列表，根据允许的收集时间，优先选择回收价值最大的Region
YongGC ,MixedGc回收所用Yong和部分Old

垃圾回收器可以马上回收内存吗？
不会马上回收，只有在必须回收时候才会进行回收，因为占用cpu开销特别大
有什么办法主动通知虚拟机进行垃圾回收？
System.gc()。Runtime.getRuntime().gc()
System.gc() 和 Runtime.gc() 会做些什么？
提示垃圾回收器进行垃圾回收，但是立刻回收还是延时回收取决于jvm

深拷贝和浅拷贝？
浅拷贝仅仅复制所拷贝的对象，而不复制它所引用的对象
把要复制的对象所引用的对象都复制了一遍


什么是分布式垃圾回收（DGC）？它是如何工作的？
RMI子系统实现基于引用计数的分布式垃圾回收（DGC),
远程对象回收时必须本地没有应用，并且远程服务也没有引用，
客户端创建远程引用时，会在服务端DGC调用dirty(),完成使用后调用clean()方法，
从dirty()开始是租期时间，到期之前必须调用dirty()来续约，如果在租期到期前不续约，则分布式垃圾回收认定客户端不再应用远程对象

串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
在 Java 中，对象什么时候可以被垃圾回收？
1、引用计数算法 2、可达性分析算法，GC roots是否可达
简述Minor GC 和 Major GC？
MinorGC新生代的GC，速度快，频率高
MajorGC老年代的GC,速度慢，频率低，一般至少会伴随一次minorGC,

Java 中垃圾收集的方法有哪些？
标记-清除：效率高，会产生大量不连续的碎片
标记-整理：先标记，然后让对象移动，再清楚，空间利用率高，效率慢
标记-复制：每次把存活对象复制到另一半，以空间换时间
分代收集：根据不同代采用不同算法

讲讲你理解的性能评价及测试指标？
停顿时间，吞吐量

常用的性能优化方式有哪些？
元空间大小，吞吐量大小，停顿时间参数，动态扩容增量，配置不同的收集器

什么是GC调优？
常见异步的手段有哪些？

Spring
为什么需要代理模式？
在不修改类的基础上，对类的功能附件与增强

讲讲静态代理模式的优点及其瓶颈？
程序可读性高，保证了业务类的重用性能，
代理对象的一个接口只服务一种类型的对象，如果要代理的方法很多，则需要写很多代码为每一个方法进行代理

对Java 接口代理模式的实现原理的理解？
实现InvocationHandler接口，
通过Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this)创建实例，

如何使用 Java 反射实现动态代理？
Java 接口代理模式的指定增强？

谈谈对Cglib 类增强动态代理的实现？

怎么理解面向切面编程的切面？
业务逻辑又进行了进一步的抽取，做成统一的服务，实现代码复用

讲解OOP与AOP的简单对比？
OOP主要针对业务

讲解JDK 动态代理和 CGLIB 代理原理以及区别？
对接口自动生成代理类
对类生成子类的方式实现代理

讲解Spring 框架中基于 Schema 的 AOP 实现原理？

讲解Spring 框架中如何基于 AOP 实现的事务管理？

谈谈对控制反转的设计思想的理解？

怎么理解 Spring IOC 容器？

Spring IOC 怎么管理 Bean 之间的依赖关系，怎么避免循环依赖？
三级缓存
singletonObjects：单例对象的cache 一级
earlySingletonObjects ：提前暴光的单例对象的Cache 。【用于检测循环引用，与singletonFactories互斥】 二级
singletonFactories ： 单例对象工厂的cache  三级
能解决setter方式注入，不能解决构造器注入
A先完成初始化第一步，然后将自己提前曝光到三级缓存里面，
B初始化，从一级找，找不到A,从二级找找不到A,从三级找找到A,然后初始化完毕，


对Spring IOC 容器的依赖注入的理解？
应用程序依赖spring容器注入某个应用程序的某个对象

说说对Spring IOC 的单例模式和高级特性？

BeanFactory 和 FactoryBean 有什么区别？
BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。
但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似 

BeanFactory 和 ApplicationContext 又有什么不同？
ApplicationContext接口,它由BeanFactory接口派生而来，ApplicationContext包含BeanFactory的所有功能

谈谈Spring Bean 创建过程中的设计模式？
spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象


数据库 https://cloud.tencent.com/developer/article/1469131

MySQL 有哪些存储引擎啊？都有什么区别？
MyIsam
InnoDB 支持事务，行级锁，外键
MyISAM 不支持事务，表级锁，保持表的行数

Float、Decimal 存储金额的区别？
Float只保存6位，

Datetime、Timestamp 存储时间的区别？
Timestamp转化为UTC存储，查询时又反转，Datetime不变
存储范围不一致，Timestamp只能存储到1970-2038年，Datetime存储1000到9999

Char、Varchar、Varbinary 存储字符的区别？
char使用固定长度的空间进行存储，经常改变的值，char优于varchar，原因是固定长度的行不容易产生碎片，自动去空格
varchar保存可变长度的字符串，使用额外的一个或两个字节存储字符串长度
Varbinary保存的是字节

对比一下B+树索引和 Hash索引？

MySQL索引类型有？
HASH,BTRee


如何管理 MySQL索引？
对Explain参数及重要参数的理解？
1、ID:是否有子查询，值越大优先级越高
2、select_type:查询类型
simple:简单的select查询,查询中不包含子查询或union查询
primary:查询中若包含任何复杂的子部分,最外层查询则被标记为primary
subquery 在select 或where 列表中包含了子查询
derived 在from列表中包含的子查询被标记为derived,mysql会递归这些子查询,把结果放在临时表里
union 做第二个select出现在union之后,则被标记为union,若union包含在from子句的子查询中,外层select将被标记为derived
union result 从union表获取结果的select
3、table:显示一行的数据时关于哪张表的
4、type:从最好到最差依次是:system>const>eq_ref>ref>range>index>All
system:表只有一行记录,这是const类型的特例,平时不会出现
const:表示通过索引一次就找到了,const即常量,它用于比较primary key或unique索引,因为只匹配一行数据,所以效率很快,如将主键置于where条件中,mysql就能将该查询转换为一个常量
eq_ref:唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配,常见于主键或唯一索引扫描
ref:非唯一性索引扫描,返回匹配某个单独值的行,它可能会找到多个符合条件的行,所以他应该属于查找和扫描的混合体
range:只检索给定范围的行,使用一个索引来选择行,如where语句中出现了between,<,>,in等查询,
这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。
index:index类型只遍历索引树,这通常比All快,因为索引文件通常比数据文件小,index是从索引中读取,all从硬盘中读取
all:全表扫描,是最差的一种查询类型
5、possible_keys:显示可能应用在这张表中的索引,一个或多个,查询到的索引不一定是真正被用到的
6、key:实际使用的索引,如果为null,则没有使用索引,因此会出现possible_keys列有可能被用到的索引,但是key列为null,表示实际没用索引。
7、key_len:表示索引中使用的字节数,而通过该列计算查询中使用的 索引长度,在不损失精确性的情况下,长度越短越好,
key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即,key_len是根据表定义计算而得么不是通过表内检索出的
8、ref显示索引的哪一列被使用了,如果可能的话是一个常数,哪些列或常量被用于查找索引列上的值
9、rows根据表统计信息及索引选用情况,大只估算出找到所需的记录所需要读取的行数
10、Extra
Using filesort:说明mysql会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取,mysql中无法利用索引完成的排序操作称为"文件排序"
Using temporary :使用了临时表保存中间结果,mysql在对查询结果排序时使用临时表,常见于order by和分组查询group by
Using index:表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。如果同时出现using where，
表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。 其中的覆盖索引含义是所查询的列是和建立的索引字段和个数是一一对应的
Using where:表明使用了where过滤
Using join buffer:表明使用了连接缓存,如在查询的时候会有多次join,则可能会产生临时表
impossible where:表示where子句的值总是false,不能用来获取任何元祖


索引利弊是什么及索引分类？
增加存储空间，更新增加IO消耗
种类：普通索引，唯一索引，主键索引，组合索引，全文索引

聚簇索引和非聚簇索引的区别？
聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
非聚簇索引：索引与数据分开存储

B+tree 如何进行优化？索引遵循哪些原则？

索引与锁有什么关系？
InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁

还有什么其他的索引类型，各自索引有哪些优缺点？
谈谈对Innodb事务的理解？
说说数据库事务特点及潜在问题？
什么是MySQL隔离级别？
有多少种事务失效的场景，如何解决？
一致性非锁定读和一致性锁定读是什么？
Innodb如何解决幻读？
讲讲Innodb行锁？
死锁及监控是什么？
自增长与锁 ，锁的算法，锁问题，锁升级是什么？
乐观锁的线程如何做失败补偿？
高并发场景（领红包）如何防止死锁，保证数据一致性？
谈谈MySQL的锁并发？
查询优化的基本思路是什么？
说说MySQL读写分离、分库分表？
表结构对性能有什么影响?
浅谈索引优化？
说说Sql优化的几点原则？
MySQL表设计及规范？
说说MySQL几种存储引擎应用场景？
MySQL常用优化方式有哪些？
MySQL常用监控？
MySQL瓶颈分析？

redis

redis数据结构有哪些？
Redis缓存穿透，缓存雪崩？
如何使用Redis来实现分布式锁？
Redis的并发竞争问题如何解决？
Redis持久化的几种方式，优缺点是什么，怎么实现的？
Redis的缓存失效策略？
Redis集群，高可用，原理？
Redis缓存分片？
Redis的数据淘汰策略？
redis队列应用场景？
分布式使用场景（储存session）？
Redis支持哪几种数据类型？

Redis主要有哪些功能？

Redis是单进程单线程的？

Redis为什么是单线程的？

其它开源软件采用的模型

使用Redis的优势？

Redis单点吞吐量

Redis相比memcached有哪些优势？

Redis有哪几种数据淘汰策略？

Redis集群方案应该怎么做？都有哪些方案？

Redis读写分离模型

Redis数据分片模型

Redis提供了哪几种持久化方式？

如何选择合适的持久化方式？

Redis常见性能问题和解决方案？

Redis支持的Java客户端都有哪些？官方推荐用哪个？

Redis哈希槽的概念？

Redis集群最大节点个数是多少？

Redis集群的主从复制模型是怎样的？

Redis集群会有写操作丢失吗？为什么？

Redis集群之间是如何复制的？

Redis如何做内存优化？

Redis回收进程如何工作的？

Redis回收使用的是什么算法？

Redis有哪些适合的场景？



网络编程

TCP建立连接和断开连接的过程？
HTTP协议的交互流程，HTTP和HTTPS的差异，SSL的交互流程？
TCP的滑动窗口协议有什么用？
HTTP协议都有哪些方法？
Socket交互的基本流程？
讲讲tcp协议（建连过程，慢启动，滑动窗口，七层模型）？
webservice协议（wsdl/soap格式，与restt办议的区别）？
说说Netty线程模型，什么是零拷贝？
TCP三次握手、四次挥手？
DNS解析过程？
TCP如何保证数据的可靠传输的？

分布式

什么是CAP定理？
说说CAP理论和BASE理论？
什么是最终一致性？最终一致性实现方式？
什么是一致性Hash？
讲讲分布式事务？
如何实现分布式锁？
如何实现分布式 Session?
如何保证消息的一致性?
负载均衡的理解？
正向代理和反向代理？
CDN实现原理？
怎么提升系统的QPS和吞吐？
Dubbo的底层实现原理和机制？
描述一个服务从发布到被消费的详细过程？
分布式系统怎么做服务治理？
消息中间件如何解决消息丢失问题？
Dubbo的服务请求失败怎么处理？
对分布式事务的理解？
如何实现负载均衡,有哪些算法可以实现?
Zookeeper的用途,选举的原理是什么?
讲讲数据的垂直拆分水平拆分？
zookeeper原理和适用场景？
zookeeper watch机制？
redis/zk节点宕机如何处理？
分布式集群下如何做到唯一序列号？
用过哪些MQ,怎么用的,和其他mq比较有什么优缺点,MQ的连接是线程安全的吗？
MQ系统的数据如何保证不丢失？
列举出能想到的数据库分库分表策略？
说说分布式缓存和一致性哈希？



1、Java事件机制包括哪三个部分？分别介绍。

2、为什么要使用线程池？

3、线程池有什么用？

4、说说几种常见的线程池及使用场景。

5、线程池都有哪几种工作队列？

6、怎么理解无界队列和有届队列？

7、线程池中的几种重要的参数及流程说明。

8、什么是反射机制？

9、说说反射机制的作用。

10、反射机制会不会有性能问题？

11、你怎么理解http协议？

12、说说http协议的工作流程。

13、http有哪些请求提交方式？

14、http中的200，302,403,404,500,503都代表什么状态？

15、http get和post有什么区别？

16、你怎么理解cookie和session，有哪些不同点？

17、什么是web缓存？有什么优点？

18、什么是https，说说https的工作原理？

19、什么是http代理服务器，有什么用？

20、什么是虚拟主机及实现原理？

21、什么是java虚拟机，我为什么要使用？

22、说说java虚拟机的生命周期及体系结构。

23、说一说java内存区域。

24、什么是分布式系统？

25、分布式系统你会考虑哪些方面？

26、讲一讲tcp协议的三次握手和四次握手流程。

27、为什么tcp建立连接协议是三次握手，而关闭连接确是四次握手呢？为什么不能用两次握手进行连接？

28、为什么tcp TIME-WAIT状态还需要等2MSL后才能返回到CLOSED状态？

29、什么是DoS、DDoS、DRDos攻击？如何防御？

30、描述一下Java异常层次结构。

31、什么是检查异常，不受检查异常，运行时异常？并分别举例说明。

32、Finally块一定会执行吗？

33、正常情况下，当在try块或catch块中遇到return语句时，finally语句在方法返回之前还是之后被执行？

34、Try、catch、finally语句块的执行顺序。

35、Java虚拟机中，数据类型可以分为哪几类？

36、怎么理解栈、堆？堆中存在什么？栈中存在什么？

37、为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？

38、在java中，什么是栈的起始点，同时也是程序的起始点？

39、为什么不把基本类型放堆中呢？

40、Java中的参数传递时传值呢?还是传引用？

41、Java中有没有指针的概念？

42、Java中，栈的大小通过什么参数来设置？

43、一个空Object对象的占多大空间？

44、对象引用类型分为那几类？

45、讲一讲垃圾回收算法。

46、如何解决内存碎片的问题？

47、如何解决同时存在的对象创建和对象回收问题？

48、讲一讲内存分代及生命周期。

49、什么情况下触发垃圾回收？

50、如何选择合适的垃圾收集算法？

51、JVM中最大堆大小有没有限制？

52、堆大小通过什么参数设置？

53、JVM有哪三种垃圾回收器？

54、吞吐量优先选择什么垃圾回收器？响应时间优先呢？

55、如何进行JVM调优？有哪些方法？

56、如何理解内存泄漏问题？有哪些情况会导致内存泄漏？如何解决？

57、从分布式系统部署角度考虑，分哪几层？

58、如何解决业务层的数据访问问题？

59、为了解决数据库服务器的负担。如何做数据库的分布？

60、什么是著名的拜占庭将军问题？

61、为什么说tcp/IP协议是不可靠的？

62、讲讲CAP理念。

63、怎么理解强一致性、单调一致性和最终一致性？

64、分布式系统设计你会考虑哪些策略？

65、最常见的数据分布式是什么？

66、谈一谈一致性哈希算法。

67、Paxos是什么？

68、什么是lease机制

69、如何理解选主算法？

70、OSI有哪七层模型？TCP/IP是哪四层模型。

71、Fabric在哪里做的共识，如何解决双花问题和节点伪造问题的，比如说A给B转账5元，给C同志1元劳务费，但是该节点作弊了怎么办？

72、拜占庭算法的理解？

73、TCP协议拥塞是怎么解决的？

74、JAVA虚拟机的理解？

75、JAVA线程池的参数都有什么？

76、有序链表和二叉搜索树在查找和插入上时间复杂度的区别？了解过红黑树么，在插入上有什么优化？

77、介绍下你觉得你做的比较好的项目，解决了哪些技术难点？

78、一个数组中有正数和负数，找出来和最大的子数组

79、16瓶水中有1瓶水有毒，小白鼠喝了有毒的水1个小时后会死，一个小白鼠可以喝多瓶水，一瓶水也可以被多个小白鼠喝，现在给1个小时时间，最少需要几只小白鼠能够判断出来14瓶水是无毒的？

80、java虚拟机垃圾回收机制

81、事务隔离级别有什么？

82、concurrentHashMap实现原理？原来使用的什么锁？CAS具体如何实现的？

83、Fabric的共识机制

84、kafka不是共识机制么？

85、一个文本有很多单词，找出来其中词频最大的k个单词？如果内存读一次装不下怎么办？

86、HashMap扩容是怎么实现的？多线程同时put会存在什么问题？

87、单例怎么写，懒汉和饿汉哪个更适合多线程？

88、线程池的参数都有什么？

89、最近在看什么书？

90、比特币的共识机制？

91、项目中的监控：那个监控指标常见的有哪些？

92、微服务涉及到的技术以及需要注意的问题有哪些？

93、注册中心你了解了哪些？

94、consul 的可靠性你了解吗？

95、consul 的机制你有没有具体深入过？有没有和其他的注册中心对比过？

96、项目用 Spring 比较多，有没有了解 Spring 的原理？AOP 和 IOC 的原理

97、Spring Boot除了自动配置，相比传统的 Spring 有什么其他的区别？

98、Spring Cloud 有了解多少？

99、Spring Bean 的生命周期

100、HashMap 和 hashTable 区别？

101、Object 的 hashcode 方法重写了，equals 方法要不要改？

102、Hashmap 线程不安全的出现场景

103、线上服务 CPU 很高该怎么做？有哪些措施可以找到问题

104、聊实验室的方向和做的项目

105、说一件你最得意的事儿，最失败的事儿和最出格的事儿

106、说一件你一直在坚持的事情

107、有几百亿个数字找出其中的中位数

108、JDK 中有哪几个线程池？

109、SQL 优化的常见方法有哪些

110、SQL 索引的顺序，字段的顺序

111、查看 SQL 是不是使用了索引？（有什么工具）

112、TCP 和 UDP 的区别？TCP 数据传输过程中怎么做到可靠的？

113、说下你知道的排序算法吧

114、常用的负载均衡，该怎么用，你能说下吗？

115、你有什么问题想问我的吗？

116、class存在哪儿，jvm结构

117、stringbuffer和stringbuilder的区别

118、Object 类中的方法

119、hashcode 和 equals 方法常用地方

120、hashmap put 方法存放的时候怎么判断是否是重复的

121、Object toString 方法常用的地方，为什么要重写该方法

122、Java 中有哪些线程安全的 Map？

123、Concurrenthashmap 是怎么做到线程安全的？

124、HashTable 你了解过吗？

125、如何保证线程安全问题？

126、volatile 的原子性问题？为什么 i++ 这种不支持原子性？从计算机原理的设计来讲下不能保证原子性的原因


线程间的通信方式、异步队列、消息延迟获取；
线程池由哪些组件组成的？你用过哪些线程池、分别是怎么使用的；
什么时候多线程会发生死锁，写一个例子；
层次遍历树并输出每层的层级；
二叉树的后序遍历，非递归算法；
说一说jdk1.8中，对hashMap的优化，对concurrentHashMap的优化；
如何解决hash冲突，如果产生冲突了，怎样在hash表中找到目标值；
有1000个数据存在hashmap中，实际的数量是多少，考虑负载因子和扩容；
MySQL的主从复制是怎么做的；
MySQL的索引，使用B+树索引的好处；
MySQL性能查看；
如何优化MySQL；
Redis是怎么做缓存的。Redis是单线程还是多线程？Redis的分布式集群怎么做?
怎样利用redis处理热点数据；
分布式锁是如何实现的；
分布式消息队列有哪些？具体应用在什么场景？具体说说你使用过的？
负载均衡怎么做，以及原因，了解过集群雪崩吗？
常见的RPC有哪些？
聊下高并发场景下的削峰、限流如何实现？
谈谈TCP三次握手的过程，如果没有第三次握手，会出现什么问题。
操作系统的用户态和核心态切换条件，为什么要切换？
cap分别指什么。


1. Java基础扎实，理解IO、多线程、集合等基础框架，对JVM原理有一定的了解；熟悉Spring,MyBatis,SpringBoot等开源框架；
2. 熟悉Java OOP和并发编程技术，有大规模系统开发和设计经验；熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制;
3. 要求对微服务化技术具有较多的经验，并熟悉Spring系列(spring cloud, spring boot, spring data)；掌握kubernetes是一个加分项；
4. 熟悉数据库应用技术与数据库架构与原理，包括关系数据库或NoSQL；精通Java JDBC/ORM框架是一个加分项；
5. 具备良好的DevOps能力，熟练掌握Docker, bash shell script是一个加分项；
6. 具备良好的分布式高可用架构思想如一致性、幂等性、CAP等是一个加分项；
7. 具有良好的沟通能力和团队合作精神；具备CI/CD和敏捷开发管理是一个加分项；
8. 有云计算业务背景者优先。