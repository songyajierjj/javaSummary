一、并发编程：

如何禁止序列化
使用transient修饰

什么是多线程并发和并行？ 
并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生

什么是线程安全问题？ 
多个线程在操作同一个共享变量的时候，预期结果和实际结果不一致。

什么是共享变量的内存可见性问题？ 
每个线程都有自己的私有内存空间（栈），线程启动后会把共享变量的值从共享内存拷贝一份到私有内存，并且再修改之后再push到共享内存，

什么是Java中原子性操作？
不会被线程调度机制打断的操作，一旦开始就不会被打断，一直到结束。

什么是Java中的CAS操作,AtomicLong实现原理？
比较并交换，内存值V,预期原值A,新值B,只有A=V的时候，才将V设置为B

什么是Java指令重排序？
在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序 分三种 编译优化的重排序，指令级并行的重排序，内存系统的重排序

Java中Synchronized关键字的内存语义是什么？
synchronized 具有使每个线程依次排队操作共享变量的功能 原子性（只能被一个线程访问），可见性，有序性（只能被一个线程访问）

Java中Volatile关键字的内存语义是什么？
写的时候会把值刷新到主内存，读的时候把本地缓存清空，从主内存读取共享变量的值 可见性 有序性

什么是伪共享,为何会出现，以及如何避免？
当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享

什么是可重入锁、乐观锁、悲观锁、公平锁、非公平锁、独占锁、共享锁？
可重入锁 可以多次获取同一把锁
乐观锁 不锁住对象
悲观锁 锁住对象
公平锁 需要排队
非公平锁 不需要排队
独占锁 每次只能由一个线程占用
共享锁 可以被多个线程共有

讲讲ThreadLocal 的实现原理？ThreadLocal 作为变量的线程隔离方式，其内部是如何做的？
Thread对象有一个ThreadLocalMap对象，key就是ThreadLocal,value可以任意值，以空间换时间，每个线程独自拥有一个变量，是隔离的

说说InheritableThreadLocal 的实现原理？
InheritableThreadLocal 是如何弥补 ThreadLocal 不支持继承的特性？

CyclicBarrier内部的实现与 CountDownLatch 有何不同？
CyclicBarrier主要基于ReentrantLock 以及 Condition 的共享唤醒线程，parties，count，每次调用await()方法时count-1，如果不等于0，
调用condition.await()方法阻塞等待，如果等于0，则调用condition.signalAll()方法唤醒所有线程执行，同时count = parties,可重用
CountDownLatch主要基于AQS实现，初始化state，每次调用coundDown()，state减1，直到减为0时，调用await()唤醒所有线程。

随机数生成器 Random 类如何使用 CAS 算法保证多线程下新种子的唯一性？
通过AtomicLong的compareAndSet来实现旧的种子跟新的种子的切换，来保证新种子的唯一性

ThreadLocalRandom 是如何利用 ThreadLocal 的原理来解决 Random 的局限性？
RANDOM是CAS操作，多个线程公用一个种子，会降低并发性能，ThreadLocalRandom实现了每个线程有自己单独的种子，提高性能

Spring 框架中如何使用 ThreadLocal 实现 request scope 作用域 Bean？

并发包中锁的实现底层（对AQS的理解）？

讲讲独占锁 ReentrantLock 原理？
CAS+CLH队列来实现,state从0开始


谈谈读写锁 ReentrantReadWriteLock 原理？
state是int类型，共32位，
读锁用高16位，表示持有读锁的线程数（sharedCount）
写锁用低16位，表示写锁的重入次数 （exclusiveCount）
状态值为 0 表示锁空闲，读锁可连续获取多个，写锁只能在没有任何读写时才能获取，写锁的线程可获取当前线程的读锁，读锁获取时如果有写锁在队列等待，该读锁也必须入队。

StampedLock 锁原理的理解？

谈下对基于链表的非阻塞无界队列 ConcurrentLinkedQueue 原理的理解？
tail,head
入队时有两种操作：
1、如果tail.next为空，将入队节点设置成尾节点的下一个节点
2、如果tail的next不为空，将入队节点设置成tail节点
ConcurrentLinkedQueue 内部是如何使用 CAS 非阻塞算法来保证多线程下入队出队操作的线程安全？

基于链表的阻塞队列 LinkedBlockingQueue 原理。
基于ReentrantLock 实现，定义了两个ReentrantLock对象一个takeLock，一个putLock，两个condition配合takeLock,putLock
阻塞队列LinkedBlockingQueue 内部是如何使用两个独占锁 ReentrantLock 以及对应的条件变量保证多线程先入队出队操作的线程安全？

分析下JUC 中倒数计数器 CountDownLatch 的使用与原理？
基于AQS实现共享锁实现，初始化state，调用countdown时候，cas方法state减1，调用await()阻塞等待
一个或者多个线程等待一组线程执行完毕，必须等所有运动员跑到终点才可以发布成绩（可以设置超时时间）
CountDownLatch 与线程的 Join 方法区别是什么？
thread.join() 方法必须等thread 执行完毕，才能向下执行
CountDownLatch 则只要计数器为0，就可以继续执行

讲讲对JUC 中回环屏障 CyclicBarrier 的使用？
让一组线程等待某个事件发生，才能继续执行，所有运动员等待枪响才可以开始跑步，

CyclicBarrier内部的实现与 CountDownLatch 有何不同？
CountDownLath让等待的线程不阻塞，CyclicBarrier让线程阻塞，可重用

Semaphore 的内部实现是怎样的？
限定线程并发数量，基于AQS实现，有公平模式和非公平模式

并发组件CopyOnWriteArrayList 是如何通过写时拷贝实现并发安全的 List？
写的时候把数据元素copy一份，通过ReetrantLock加锁，如果读取的时候读的是老数据，写入之后把list数组地址指向新的地址

同步与异步？阻塞与非阻塞？

1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。
2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）
3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者

synchronized 
对象被创建在堆中。并且对象在内存中的存储布局方式可以分为3块区域：对象头、实例数据、对齐填充。
同步代码块
synchronized的对象锁，其指针指向的是一个monitor对象（由C++实现）的起始地址。每个对象实例都会有一个 monitor。
其中monitor可以与对象一起创建、销毁；亦或者当线程试图获取对象锁时自动生成。
字节码中并没有monitorenter指令和monitorexit指令，取得代之的是ACC_SYNCHRONIZED标识，JVM通过ACC_SYNCHRONIZED标识，就可以知道这是一个需要同步的方法

重量级锁，自旋锁，轻量级锁，偏向锁
https://www.cnblogs.com/linghu-java/p/8944784.html
偏向锁获取过程：
访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。
如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。
如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。
如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，
然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）
执行同步代码

二、JVM

Java 内存分配？
程序计数器，虚拟机栈，本地方法栈，堆，方法区
Java 堆的结构是什么样子的？
新生代（Eden,from/to） 1/3,老年代 2/3

什么是堆中的永久代（Perm Gen space）?
方法区，存储class、运行时常量池、字段、方法、代码、JIT代码等，是一个规范，规定了这个里面要存储什么东西
永久代是方法区的一个实现

说说各个区域的作用？
程序计数器(线程私有)：一个指针，指向下一条指令的地址，由执行引擎读取下一条指令，内存非常小，
本地方法栈(线程私有)：登记native方法，执行引擎执行时加载本地方法库，非java语言的方法
方法区(线程共享):所有定义方法的信息，静态变量+常量+类信息(构造方法/接口定义)
java栈(线程私有):java线程执行方法的内存模型，一个线程对应一个栈，每个方法执行时会创建一个栈帧（局部变量，操作数栈，动态链接，方法出库等），无垃圾回收，线程结束就释放


Java 中会存在内存泄漏吗，简述一下？
长生命周期的对象引用一个短生命周期的对象

Java 类加载过程？
加载：在硬盘上查找并通过IO读入字节码文件
验证：1、文件格式验证（class文件的格式规范）2、元数据验证（语法分析）3、字节码验证（语义分析）4、符号引用验证
准备：为类变量分配内存并且设置初始化值的，都在方法区分配，只初始化静态字段，并赋值初始化值（final类型的直接代码定义的值），不是代码的值
解析：虚拟机将符号引用转化为直接引用的过程，主要针对类或接口、类方法、接口方法、方法类型、方法句柄、字段以及调用点限定符等符号进行
初始化：执行java程序，初始化用户代码写的值
使用：
卸载

描述一下 JVM 加载 Class 文件的原理机制?
什么是类加载器？
动态的把类加载到jvm，就是把class文件从磁盘读取到内存中
类加载器有哪些？
启动类加载器、扩展类加载器、系统类加载器、用户自定义加载器
类加载器双亲委派模型机制？
先委托父类加载器寻找目标类，找不到的情况下在自己路劲下查找病载入目标类

什么是tomcat类加载机制？
启动类->扩展类->应用程序类->common类加载器（/common/*）->1、catalina类加载器（/server/*）2、shared类加载器->Webapp类加载器->jsp类加载器
tomcat是一个web容器，解决的问题
部署多个服务时，保证每个服务的同一个类的不同版本是隔离的，
相同的类库版本可以共享
自己依赖的类库要跟应用程序的隔离
支持jsp修改不重启
如果使用默认加载机制，无法加载两个相同类库的不同版本
每个jsp对应唯一一个类加载器，当jsp修改后，就卸载这个类加载器，重新创建一个类加载器，重新加载jsp文件


什么是GC? 为什么要有 GC？
GC就是垃圾回收，如果没有GC,使用对象的时候会一直占用内存空间，造成内存溢出
简述一下Java 垃圾回收机制？
在新生代分配对象时，如果不够分配，先执行一次minorGC，执行之后如果内存还不够用，
就去老年代申请，如果老年代也没有足够的内存就执行majroGC,如果GC之后内存还是不够就包内存溢出。

如何判断一个对象是否存活？
通过根节点是否可达

垃圾回收的优点和原理，并考虑 2 种回收机制？
防止内存泄露，有效使用内存，编写程序不需要考虑垃圾回收
标记清除，标记整理

垃圾回收器的基本原理是什么？
侦测java程序的运行情况，当发现有些对象可以回收时，就会销毁这些对象，并且释放内存
Serial收集器:串行，单线程，新生代复制算法，老年代标记整理 单cpu场景，单线程效率高
ParNew收集器:串行，多线程，新生代复制算法，老年代标记整理
Parallel Scavenge收集器:关注吞吐量，高效率利用CPU,新生代复制算法，老年代标记整理  jdk1.8默认新生代
Serial Old收集器:CMS收集器的后备方案
Parallel Old收集器:Parallel Scavenge的老年代版本，关注吞吐量  jdk1.8默认老年代
CMS收集器：主要老年代使用，并发收集，低停顿，标记-清除算法实现，
初始标记：暂停用户线程
并发标记：跟用户线程同时开启，
重新标记：处理并发标记自己，影响初始标记的，停顿时间比初始标记时间长
并发清除：并发未标记的区域做清扫
缺点：会抢CPU资源，无法处理浮动垃圾，并发标记产生的垃圾，产生不连续的内存碎片
G1收集器：既满足低停顿，又有高吞吐量
G1讲堆划分为多个大小相等的独立区域（region),Eden,Survivor,old,Humongous
region 大小一致，数值是在 1M 到 32M 字节之间的一个 2 的幂值数，JVM 会尽量划分 2048 个左右、同等大小的 region
新生代和老年代不在物理隔阂，大对象直接进去Humongous，不用进老年代，避免fullGC
缺点：region 大小和大对象很难保证一致，这会导致空间的浪费；特别大的对象是可能占用超过一个 region 的。
并且，region 太小不合适，会令你在分配大对象时更难找到连续空间，这是一个长久存在的情况。
优点：1、并行并发2、分代收集，空间整合：整体看是标记整理，局部看是复制，可预测的停顿
1、初始标记：与常规的年轻代相关，停顿
2、并发标记：在整个堆上标记，
3、最终标记：停顿
4、筛选回收：停顿
在后台维护了一个优先列表，根据允许的收集时间，优先选择回收价值最大的Region
YongGC ,MixedGc回收所用Yong和部分Old

垃圾回收器可以马上回收内存吗？
不会马上回收，只有在必须回收时候才会进行回收，因为占用cpu开销特别大
有什么办法主动通知虚拟机进行垃圾回收？
System.gc()。Runtime.getRuntime().gc()
System.gc() 和 Runtime.gc() 会做些什么？
提示垃圾回收器进行垃圾回收，但是立刻回收还是延时回收取决于jvm

深拷贝和浅拷贝？
浅拷贝仅仅复制所拷贝的对象，而不复制它所引用的对象
把要复制的对象所引用的对象都复制了一遍


什么是分布式垃圾回收（DGC）？它是如何工作的？
RMI子系统实现基于引用计数的分布式垃圾回收（DGC),
远程对象回收时必须本地没有应用，并且远程服务也没有引用，
客户端创建远程引用时，会在服务端DGC调用dirty(),完成使用后调用clean()方法，
从dirty()开始是租期时间，到期之前必须调用dirty()来续约，如果在租期到期前不续约，则分布式垃圾回收认定客户端不再应用远程对象

串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
在 Java 中，对象什么时候可以被垃圾回收？
1、引用计数算法 2、可达性分析算法，GC roots是否可达
简述Minor GC 和 Major GC？
MinorGC新生代的GC，速度快，频率高
MajorGC老年代的GC,速度慢，频率低，一般至少会伴随一次minorGC,

Java 中垃圾收集的方法有哪些？
标记-清除：效率高，会产生大量不连续的碎片
标记-整理：先标记，然后让对象移动，再清楚，空间利用率高，效率慢
标记-复制：每次把存活对象复制到另一半，以空间换时间
分代收集：根据不同代采用不同算法

讲讲你理解的性能评价及测试指标？
停顿时间，吞吐量

常用的性能优化方式有哪些？
元空间大小，吞吐量大小，停顿时间参数，动态扩容增量，配置不同的收集器

什么是GC调优？
常见异步的手段有哪些？

CPU过高
（1）第一步  ， 用jps 查看java pid 
（2）第二步，显示线程列表 ps -mp 42 -o THREAD,tid,time
top -H -p 1920
jstat -gcutil 进程ID
（3）第三步，选择自己要看的线程id , 即tid。将其转换成16进制格式。当时选择的是tid 为211.  printf "%x\n" 211
（4）第四步  打印堆栈信息
jstack 进程号 | grep 线程号（16进制）
（5）第五步 从堆栈信息中定位问题代码
查看该VM参数
jinfo -flags pid
查看统计结果
jmap -heap pid
查看对象实例
jmap -histo 15178 | less

内存溢出
2.1 收集内存溢出Dump文件
jmap命令收集
jmap -dump:live,format=b,file=/opt/web_app/dump.hprof pid。
2.2 分析Dump文件
使用工具MAT(MemoryAnalyzer)进行分析
使用jvisualvm来分析dump文件：

jvisualvm是JDK自带的Java性能分析工具，在JDK的bin目录下，文件名就叫jvisualvm.exe

三、Spring

为什么需要代理模式？
在不修改类的基础上，对类的功能附件与增强

讲讲静态代理模式的优点及其瓶颈？
程序可读性高，保证了业务类的重用性能，
代理对象的一个接口只服务一种类型的对象，如果要代理的方法很多，则需要写很多代码为每一个方法进行代理

对Java 接口代理模式的实现原理的理解？
实现InvocationHandler接口，
通过Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this)创建实例，

如何使用 Java 反射实现动态代理？
Java 接口代理模式的指定增强？

谈谈对Cglib 类增强动态代理的实现？

怎么理解面向切面编程的切面？
业务逻辑又进行了进一步的抽取，做成统一的服务，实现代码复用

讲解OOP与AOP的简单对比？
OOP主要针对业务

讲解JDK 动态代理和 CGLIB 代理原理以及区别？
对接口自动生成代理类
对类生成子类的方式实现代理

讲解Spring 框架中基于 Schema 的 AOP 实现原理？

讲解Spring 框架中如何基于 AOP 实现的事务管理？

Spring事务传播机制
传播行为	含义
PROPAGATION_REQUIRED	表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务
PROPAGATION_SUPPORTS	表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行
PROPAGATION_MANDATORY	表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常
PROPAGATION_REQUIRED_NEW	表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager
PROPAGATION_NOT_SUPPORTED	表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager
PROPAGATION_NEVER	表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常
PROPAGATION_NESTED	表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。
			注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务

@Transactional的参数
value 事务管理器
transactionManager 
propagation 传播机制
isolation 隔离级别
timeout 超时时间
readOnly 是否只读
rollbackFor 异常
rollbackForClassName
noRollbackFor
noRollbackForClassName
@Transactional 注解只能应用到 public 可见度的方法上。
失败的原理是：@Transactional是基于动态代理来实现的，非public的方法，他@Transactional的动态代理对象信息为空，所以不能回滚。
2.在类内部没有添加@Transactional的方法，调用了@Transactional方法时，当你调用时，他也不会回滚
失败的原理：@Transactional是基于动态代理对象来实现的，而在类内部的方法的调用是通过this关键字来实现的，没有经过动态代理对象，所以事务回滚失效。
默认情况下，Spring会对unchecked异常进行事务回滚；如果是checked异常则不回滚。 
辣么什么是checked异常，编译时候需要手工设置捕获或者抛出异常，否则编译失败
什么是unchecked异常，在运行时抛出的异常，空指针，数组越界等

只读事务： 
@Transactional(propagation=Propagation.NOT_SUPPORTED,readOnly=true) 


谈谈对控制反转的设计思想的理解？

怎么理解 Spring IOC 容器？

Spring IOC 怎么管理 Bean 之间的依赖关系，怎么避免循环依赖？
三级缓存
singletonObjects：单例对象的cache 一级
earlySingletonObjects ：提前暴光的单例对象的Cache 。【用于检测循环引用，与singletonFactories互斥】 二级
singletonFactories ： 单例对象工厂的cache  三级
能解决setter方式注入，不能解决构造器注入
A先完成初始化第一步，然后将自己提前曝光到三级缓存里面，
B初始化，从一级找，找不到A,从二级找找不到A,从三级找找到A,然后初始化完毕，


对Spring IOC 容器的依赖注入的理解？
应用程序依赖spring容器注入某个应用程序的某个对象

说说对Spring IOC 的单例模式和高级特性？

BeanFactory 和 FactoryBean 有什么区别？
BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。
但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似 

BeanFactory 和 ApplicationContext 又有什么不同？
ApplicationContext接口,它由BeanFactory接口派生而来，ApplicationContext包含BeanFactory的所有功能

谈谈Spring Bean 创建过程中的设计模式？
spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象

SrpingBean的生命周期
实例化：构造器注入或者简单实例化
设置bean的Aware：BeanNameAware，BeanClassLoaderAware，ResourceLoaderAware,ApplicationContextAware,BeanFactoryAware
BeanPostProcessor.postProcessBeforeInitialization(Object bean, String beanName) 后置处理器在初始化之前的工作
InitializingBean.afterPorpertiesSet     bean的属性设置
BeanPostProcessor.postProcessAfterInitialization(Object bean, String beanName)  后置处理器在初始化之后的工作
SmartInitializingSingleton.afterSingletonsInstantiated 单例bean在初始化之后的设置
SmartLifecycle.start 生命周期开始
bean已经在spring容器的管理下，可以做我们想做的事
SmartLifecycle.stop(Runnable callback) 生命周期停止
DisposableBean.destroy() bean销毁

Spring AOP / AspectJ AOP 的区别？
Spring AOP属于运行时增强，而AspectJ是编译时增强。
Spring AOP基于代理（Proxying），
而AspectJ基于字节码操作（Bytecode Manipulation）。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。如果切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多。




四、数据库 
https://cloud.tencent.com/developer/article/1469131

interactive_timeout = 1800 交互式链接超时时间（通过mysql客户端）
wait_timeout = 1800 非交互式链接超时时间（通过jdbc链接）

MySQL 有哪些存储引擎啊？都有什么区别？
MyIsam
InnoDB 支持事务，行级锁，外键
MyISAM 不支持事务，表级锁，保持表的行数

innoDB行锁是通过给索引上的索引项加锁来实现的

Float、Decimal 存储金额的区别？
Float只保存6位，

Datetime、Timestamp 存储时间的区别？
Timestamp转化为UTC存储，查询时又反转，Datetime不变
存储范围不一致，Timestamp只能存储到1970-2038年，Datetime存储1000到9999

Char、Varchar、Varbinary 存储字符的区别？
char使用固定长度的空间进行存储，经常改变的值，char优于varchar，原因是固定长度的行不容易产生碎片，自动去空格
varchar保存可变长度的字符串，使用额外的一个或两个字节存储字符串长度
Varbinary保存的是字节

对比一下B+树索引和 Hash索引？

MySQL索引类型有？
HASH,BTRee


如何管理 MySQL索引？
对Explain参数及重要参数的理解？
1、ID:是否有子查询，值越大优先级越高
2、select_type:查询类型
simple:简单的select查询,查询中不包含子查询或union查询
primary:查询中若包含任何复杂的子部分,最外层查询则被标记为primary
subquery 在select 或where 列表中包含了子查询
derived 在from列表中包含的子查询被标记为derived,mysql会递归这些子查询,把结果放在临时表里
union 做第二个select出现在union之后,则被标记为union,若union包含在from子句的子查询中,外层select将被标记为derived
union result 从union表获取结果的select
3、table:显示一行的数据时关于哪张表的
4、type:从最好到最差依次是:system>const>eq_ref>ref>range>index>All
system:表只有一行记录,这是const类型的特例,平时不会出现
const:表示通过索引一次就找到了,const即常量,它用于比较primary key或unique索引,因为只匹配一行数据,所以效率很快,如将主键置于where条件中,mysql就能将该查询转换为一个常量
eq_ref:唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配,常见于主键或唯一索引扫描
ref:非唯一性索引扫描,返回匹配某个单独值的行,它可能会找到多个符合条件的行,所以他应该属于查找和扫描的混合体
range:只检索给定范围的行,使用一个索引来选择行,如where语句中出现了between,<,>,in等查询,
这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。
index:index类型只遍历索引树,这通常比All快,因为索引文件通常比数据文件小,index是从索引中读取,all从硬盘中读取
all:全表扫描,是最差的一种查询类型
5、possible_keys:显示可能应用在这张表中的索引,一个或多个,查询到的索引不一定是真正被用到的
6、key:实际使用的索引,如果为null,则没有使用索引,因此会出现possible_keys列有可能被用到的索引,但是key列为null,表示实际没用索引。
7、key_len:表示索引中使用的字节数,而通过该列计算查询中使用的 索引长度,在不损失精确性的情况下,长度越短越好,
key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即,key_len是根据表定义计算而得么不是通过表内检索出的
8、ref显示索引的哪一列被使用了,如果可能的话是一个常数,哪些列或常量被用于查找索引列上的值
9、rows根据表统计信息及索引选用情况,大只估算出找到所需的记录所需要读取的行数
10、Extra
Using filesort:说明mysql会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取,mysql中无法利用索引完成的排序操作称为"文件排序"
Using temporary :使用了临时表保存中间结果,mysql在对查询结果排序时使用临时表,常见于order by和分组查询group by
Using index:表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。如果同时出现using where，
表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。 其中的覆盖索引含义是所查询的列是和建立的索引字段和个数是一一对应的
Using where:表明使用了where过滤
Using join buffer:表明使用了连接缓存,如在查询的时候会有多次join,则可能会产生临时表
impossible where:表示where子句的值总是false,不能用来获取任何元祖


索引利弊是什么及索引分类？
增加存储空间，更新增加IO消耗
种类：普通索引，唯一索引，主键索引，组合索引，全文索引

(1)索引并非越多越好，大量的索引不仅占用磁盘空间，而且还会影响insert,delete,update等语句的性能
(2)避免对经常更新的表做更多的索引，并且索引中的列尽可能少；对经常用于查询的字段创建索引，避免添加不必要的索引
(3)数据量少的表尽量不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果
(4)在条件表达式中经常用到不同值较多的列上创建索引，在不同值很少的列上不要建立索引。比如性别字段只有“男”“女”俩个值，就无需建立索引。如果建立了索引不但不会提升效率，反而严重减低数据的更新速度
(5)在频繁进行排序或者分组的列上建立索引，如果排序的列有多个，可以在这些列上建立联合索引。

聚簇索引和非聚簇索引的区别？
聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
非聚簇索引：索引与数据分开存储

讲讲索引的分类？你知道哪些
从物理存储角度: 聚簇索引和非聚簇索引
从数据结构角度: B+树索引、hash索引、FULLTEXT索引、R-Tree索引
从逻辑角度:
主键索引：主键索引是一种特殊的唯一索引，不允许有空值
普通索引或者单列索引
多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合
唯一索引或者非唯一索引
空间索引：空间索引是对空间数据类型的字段建立的索引，
MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。

如何避免回表查询?什么是索引覆盖?
在索引上就能找到结果，就不用回表去查询
覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引不存储索引列的值，所以mysql只能用B+ tree索引做覆盖索引

如果数据是唯一的，建立唯一索引还是普通索引
唯一索引影响插入速度，但是有效提高查询速度
为什么唯一索引的插入速度比不上普通索引？为什么唯一索引的查找速度比普通索引快？
在进行非聚簇索引的插入时，先判断插入的索引页是否在内存中。如果在，则直接插入；
如果不在，则先放入Insert Buffer 中，然后再以一定频率和情况进行Insert Buffer和原数据页合并(merge)操作。
这么做的优点:能将多个插入合并到一个操作中，就大大提高了非聚簇索引的插入性能。
InnoDB 从 1.0.x 版本开始引入了 Change Buffer，可以算是对 Insert Buffer 的升级。
从这个版本开始，InnoDB 存储引擎可以对 insert、delete、update 都进行缓存。
唯一索引的插入比普通索引慢的原因就是:唯一索引无法利用Change Buffer普通索引可以利用Change Buffer
为什么唯一索引的更新不使用 Change Buffer？
因为唯一索引为了保证唯一性，需要将数据页加载进内存才能判断是否违反唯一性约束。
但是，既然数据页都加载到内存了，还不如直接更新内存中的数据页，没有必要再使用Change Buffer。
普通索引在找到满足条件的第一条记录后，还需要判断下一条记录，直到第一个不满足条件的记录出现。
唯一索引在找到满足条件的第一条记录后，直接返回，不用判断下一条记录了。

mysql索引是什么结构的？用红黑树可以么?
B+ Tree。
AVL树和红黑树基本都是存储在内存中才会使用的数据结构。在大规模数据数据存储的时候，显然不能将全部数据全部加载进内存，因此如果采用红黑树，就会造成频繁IO，效率低下。

6、mysql某表建了多个单索引，查询多个条件时如何走索引的？
Mysql在优化器中有一个优化器称为Range 优化器，负责进行范围查询的优化！
那么该优化器计算执行成本有两种方式index dive与index statistics。
它们是MySQL优化器对开销代价的估算方法，前者统计速度慢但是能得到精准的值，后者统计速度快但是数据未必精准。
对于index dive:
计算成本的方式为
COST = CPU COST + IO COST
其中CPU COST指的是处理返回记录所花的开销。而IO COST指的是读取页面的开销。
mysql会对每种索引的执行情况，进行上述成本计算，最后以成本小的方式进行执行。
但是呢，在某些情况下mysql执行index dive的成本太大。因此优化器会选择以index statistics方式进行估算成本。具体如下：SHOW INDEX FROM tbl_name [FROM db_name]

B+tree 如何进行优化？索引遵循哪些原则？

索引与锁有什么关系？
InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁

还有什么其他的索引类型，各自索引有哪些优缺点？

谈谈对Innodb事务的理解？
A原子性 C一致性 I隔离性 D持久性
ACD通过redo log(重做日志)和(Undo log)实现，隔离性通过锁来实现
Redo log 物理日志
重做日志用来实现事务的持久性，即D特性。它由两部分组成：
①内存中的重做日志缓冲
②重做日志文件
Undo log 逻辑日志
实现事务回滚
实现mvcc

说说数据库事务特点及潜在问题？

什么是MySQL隔离级别？
读未提交  脏读，不可重复读，幻读
读已提交  不可重复读，幻读
可重复读  幻读
串行化

脏读：所谓的脏读，其实就是读到了别的事务回滚前的脏数据。比如事务B执行过程中修改了数据X，在未提交前，事务A读取了X，而事务B却回滚了，这样事务A就形成了脏读。
也就是说，当前事务读到的数据是别的事务想要修改成为的但是没有修改成功的数据。

不可重复读：事务A首先读取了一条数据，然后执行逻辑的时候，事务B将这条数据改变了，然后事务A再次读取的时候，发现数据不匹配了，就是所谓的不可重复读了。
也就是说，当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配，也就照应了不可重复读的语义。

幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据，导致事务A再次搜索发现有N+M条数据了，就产生了幻读。
也就是说，当前事务读第一次取到的数据比后来读取到数据条目少。

1、事务隔离级别为读提交时，写数据只会锁住相应的行
2、事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，
更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。
、事务隔离级别为串行化时，读写数据都会锁住整张表


有多少种事务失效的场景，如何解决？
Transactional的异常控制，默认是Check Exception 不回滚，unCheck Exception回滚

一致性非锁定读和一致性锁定读是什么？
一致性非锁定读指的是：要读取的行被加了X锁（排它锁），这时候读取操作不会等待行上锁的释放，而是会读取行的一个快照数据
行记录可能有多个版本
在RC下读取的是最新的一份快照数据，在RR下读取的是事务开始的数据版本
一致性锁定读在事务读取时就把记录锁住 for update, lock in share mode


表级锁分为读锁和写锁
读锁：LOCK TABLE table_name [ AS alias_name ] READ
申请前提是没有其它线程对该表使用写锁，申请之后其它线程可以执行读操作，不能执行写操作
写锁：LOCK TABLE table_name [AS alias_name] [ LOW_PRIORITY ] WRITE
可以指定优先级，

行级锁：锁粒度最细的一种锁，减少数据库操作的冲突，分为共享锁和排他锁
共享锁(S LOCK): SELECT ...LOCK IN SHARE MODE;
mysql会对查询结果的每行都加共享锁，没有其他线程对查询结果的任何一行使用排他锁时，可以成功申请共享锁，
排他锁(X LOCK)：SELECT ...LOCK FOR UPDATE;
mysql会对查询结果的每行都加排他锁，没有其他线程对查询结果的任何一行使用排他锁时，可以成功申请排他锁，
行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大

死锁：死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象，若无外力作用,它们都将无法推进下去.
产生条件：
互斥条件-指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放
请求和保持条件-指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放
不可剥夺条件-指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放
环路等待条件-指在发生死锁时，必然存在一个进程――资源的环形链，即进程集合{P0，P1，P2，・・・，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源

死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，
这是一种保证系统不进入死锁状态的动态策略。 如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的。
有序资源分配法
1、对它所必须使用的而且属于同一类的所有资源，必须一次申请完；
2、在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。
银行家算法

Innodb如何解决幻读？
多版本并发控制（MVCC)
每一行都冗余了两个字段，一个是行的创建版本，一个是行的删除版本
版本号存在information_schema.INNODB_TRX表中
版本号（trx_id）随着每次事务开启自增
每次取的时候取创建版本小于当前的版本，删除版本大于当前的版本

死锁及监控是什么？
自增长与锁：轻量级互斥量的自增长实现机制
锁的算法，锁问题，锁升级是什么？

乐观锁的线程如何做失败补偿？
1、消息队列处理
2、aop(自定义异常，更新失败抛出异常，重试）

谈谈MySQL的锁并发？
查询优化的基本思路是什么？
explain查看执行计划

说说MySQL读写分离、分库分表？
表结构对性能有什么影响?
浅谈索引优化？
说说Sql优化的几点原则？
MySQL表设计及规范？
说说MySQL几种存储引擎应用场景？
MySQL常用优化方式有哪些？

MySQL常用监控？
指标分类	指标名称	指标说明
性能类指标	QPS	数据库每秒处理的请求数量
		TPS	数据库每秒处理的事务数量
		并发数	数据库实例当前并行处理的会话数量
		连接数	连接到数据库会话的数量
		缓存命中率	查询命中缓存的比例
高可用指标	可用性	数据库是否可以正常对外服务
		阻塞	当前阻塞的会话数
		慢查询	慢查询情况
		主从延迟	主从延迟时间
		主从状态	主从链路是否正常
		死锁	查看死锁信息

MySQL瓶颈分析？

mysql的两个机制
MySQL支持单向、双向、链式级联、异步复制，5.5版本之后加入的半同步复制，5.6版本之后的GTID复制，MySQL5.7的多源复制、并行复制、loss-less复制
半同步复制，用来解决主库数据丢失问题 通过从库ack确认
并行复制，解决同步延时问题 从库开启多个并行读取relay 
log中不同库的日志，并行重放不同库的日志，库级别的并行
异步复制是MySQL默认的复制方式，主库写入binlog日志后即可成功返回客户端，无须等待binlog日志传递给从库的过程，但是一旦主库宕机，就有可能出现丢失数据的情况
半同步复制提升了主从之间数据的一致性，让复制更加安全可靠
AFTER_COMMIT 5.6版本的默认值，主库将每个事务写入binlog，并传递给从库，刷新到中继日志中，同时主库提交事务。之后主库开始等待从库的反馈，只有收到从库的回复之后，master才将commit OK的结果反馈给客户端 
AFTER_SYNC 5.7版本新增，也是默认的半同步复制方式。主库将每个事务写入binlog并传递给从库，刷新到中继日志中，主库开始等待从库的反馈，接收到从库的回复之后，再提交事务并且返回commit OK结果给客户端。

五、redis

redis数据结构有哪些？
string,list,set,zset,hash

Redis缓存穿透，缓存雪崩？
缓存穿透：恶意用户模拟请求许多缓存中不存在的数据，导致请求落库，造成数据库异常
解决方案：1使用互斥锁排队 2、接口限流、熔断、降级  3、布隆过滤器

接口限流、熔断、降级方案

如何使用Redis来实现分布式锁？
redis.setnx expire

Redis的并发竞争问题如何解决？
利用redis自带的incr命令
使用乐观锁的方式
在客户端加锁

Redis持久化的几种方式，优缺点是什么，怎么实现的？
RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储
save <seconds> <changes> 每隔多少秒 有多少个操作
AOF 记录日志 ，增量持久化
1、no，不调用fsync，即由操作系统自己决定何时刷新数据，这种速度很快。
2、always，每次写入追加日志后调用fsync，速度慢，但是最安全。
3、everysec，每一秒调用fsync，折中方案。

RDB存在哪些优势呢？
1). 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。
比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。
2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。
3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。
4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。

RDB又存在哪些劣势呢？
1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。
2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。

AOF的优势有哪些呢？
1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。
事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。
而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。
2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。
然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。
3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，
同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。
4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。

AOF的劣势有哪些呢？
1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。

二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），
还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。

Redis的缓存失效策略？
过期键删除策略:1、定期随机删除 2、惰性删除
内存淘汰机制：
volatile-lru ：在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把 redis 既当缓存，又做持久化存储的时候才用
allkeys-lru ： 移除最近最少使用的key （推荐）
volatile-random ： 在设置了过期时间的键空间中，随机移除一个键，不推荐
allkeys-random ： 直接在键空间中随机移除一个键
volatile-ttl ： 在设置了过期时间的键空间中，有更早过期时间的key优先移除 不推荐
noeviction ： 不做过键处理，只返回一个写操作错误。 不推荐


Redis集群，高可用，原理？
(1).Redis 集群的分片特征在于将键空间分拆了16384个槽位，每一个节点负责其中一些槽位。 
(2).Redis提供一定程度的可用性,可以在某个节点宕机或者不可达的情况下继续处理命令. 
(3).Redis 集群中不存在中心(central)节点或者代理(proxy)节点， 集群的其中一个主要设计目标是达到线性可扩展性(linear scalability)

 集群的使用公式HASH_SLOT=CRC16(key) mod 16384 计算key属于哪个槽

redis队列应用场景？
lpush,lpop,rpush,rpop

分布式使用场景（储存session）？
session,分布式锁

Redis主要有哪些功能？

Redis是单进程单线程的？
单线程

Redis为什么是单线程的？
内存数据库，
单线程减少上下文切换，
核心是基于非阻塞的 IO 多路复用机制
redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型
文件事件处理器的结构包含 4 个部分：
多个 socket
IO 多路复用程序
文件事件分派器
事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，
会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理

其它开源软件采用的模型

使用Redis的优势？

Redis单点吞吐量
qps 10万/秒 tps 8万/秒

Redis相比memcached有哪些优势？
redis 支持复杂的数据结构
redis 原生支持集群模式
redis 支持持久化
redis 单线程性能更好


Redis集群方案应该怎么做？都有哪些方案？
客户端分片
codis
原生集群

Redis读写分离模型

Redis常见性能问题和解决方案？

Redis支持的Java客户端都有哪些？官方推荐用哪个？
Redisson,Jedis，lettuce

Redis集群的主从复制模型是怎样的？

Redis集群会有写操作丢失吗？为什么？

Redis集群之间是如何复制的？
①从数据库向主数据库发送sync(数据同步)命令。
②主数据库接收同步命令后，会保存快照，创建一个RDB文件。
③当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。
④主数据库将缓冲区的所有写命令发给从服务器执行。
⑤以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。

Redis如何做内存优化？

Redis有哪些适合的场景？

Redis缓存一致性问题
1先更新数据库再更新缓存 （不可行）
线程A更新了数据库
线程B更新了数据库
线程B更新了缓存
线程A更新了缓存
正确结果应为缓存A数据，但是因为网络原因或者其他原因，导致缓存了B数据，出现脏数据问题
2先删除缓存再更新数据库
出现问题
请求A进行写操作，删除缓存
请求B查询发现缓存不存在
请求B去数据库查询得到旧值
请求B将旧值写入缓存
请求A将新值写入数据库
上述情景则会导致缓存不一致问题出现
使用延时双删策略
先删除再更新然后延时一段时间再更新数据库
3先更新数据库，再删缓存
缓存刚好失效
请求A查询数据库，得一个旧值
请求B将新值写入数据库
请求B删除缓存
请求A将查到的旧值写入缓存

六、MQ
1. 为什么使用 MQ, MQ 如何选型, 消息可靠性如何保证, 如何保证幂等
mq 消息可靠性,幂等如何保证
MQ作用
1、解耦
2、可靠投递
3、广播
4、最终一致性
5、流量削峰
6、消息投递保证
7、异步通信（支持同步）
8、提高系统吞吐、健壮性
1、异步
2、解耦
3、削峰
缺点：系统可用性降低、复杂度增高
选型
特性	     ActiveMQ	RabbitMQ	RocketMQ	kafka
开发语言	java	erlang	        java	        scala
单机吞吐量	万级	万级	        10万级	        10万级
时效性	        ms级	us级	        ms级	        ms级以内
可用性	高(主从架构)	高(主从架构)	非常高(分布式架构)	非常高(分布式架构)
功能特性	
成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好	
基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富	
MQ功能比较完备，扩展性佳	
只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。
RabbitMQ消息可靠性保证
1生产者 transaction 或者 confirm 
2消息队列丢失数据 queue持久化 消息持久化
3消费者丢失数据 关闭自动 ack，手动ack
Rabbitmq如何保证消息有序

kafka每一个 topic 在硬盘上用一个 logfile 表示，通过顺序读写可以使性能非常高，
但当多个 topic 的多个 partition 分布在同一台机器上时，原本的顺序读写就变为随机读写

ExchangeTypes
fanout direct topic
binding key 把exchange和queue关系确定
routing key 到queue

消息队列已经逐渐成为企业IT系统内部通信的核心手段。
它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。

1.消息队列不是万能的，对于需要强事务保证而且延迟敏感的，RPC是优于消息队列的。
2.对于一些无关痛痒，或者对于别人非常重要但是对于自己不是那么关心的事情，可以利用消息队列去做。
3.支持最终一致性的消息队列，能够用来处理延迟不那么敏感的“分布式事务”场景，而且相对于笨重的分布式事务，可能是更优的处理方式。
4.当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的“漏斗”，在下游有能力处理的时候，再进行分发。
5.如果下游有很多系统关心你的系统发出的通知的时候，果断地使用消息队列吧。

七、RPC

RPC的一般需要经历4个步骤：
1、建立通信
首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接，主要是通过在客户端和服务器之间建立TCP连接。
2、服务寻址
要解决寻址的问题，A服务器上如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称是什么。
3、网络传输
1）序列化
当A服务器上的应用发起一个RPC调用时，调用方法和参数数据都需要先进行序列化。
2）反序列化
当B服务器接收到A服务器的请求之后，又需要对接收到的参数等信息进行反序列化操作。
4、服务调用
B服务器进行本地调用（通过代理Proxy）之后得到了返回值，此时还需要再把返回值发送回A服务器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A服务器。
通常，一次完整的PRC调用需要经历如上4个步骤。

dubbo跟cloud区别

2. 用过 dubbo吗? 
dubbo四大组件
Provider：提供者
Consumer：消费者
registry：注册中心（相当于中介）
monitor：监控中心
container：服务容器
设计一个 rpc 框架.

RPC和MQ的区别和关联

1.在架构上，RPC和MQ的差异点是，Message有一个中间结点Message Queue，可以把消息存储。
2.同步调用：对于要立即等待返回处理结果的场景，RPC是首选
3.MQ 的使用，一方面是基于性能的考虑，比如服务端不能快速的响应客户端（或客户端也不要求实时响应），需要在队列里缓存。
另外一方面，它更侧重数据的传输，因此方式更加多样化，除了点对点外，还有订阅发布等功能。
4.而且随着业务增长，有的处理端处理量会成为瓶颈，会进行同步调用改造为异步调用，这个时候可以考虑使用MQ。

微服务
它的主要特点是组件化、松耦合、自治、去中心化
根据业务模块划分服务种类。
每个服务可以独立部署并且互相隔离。
通过轻量的 API 调用服务。
服务需要保证良好的高可用性。
微服务能够使我们的开发效率更高，沟通成本更低，响应速度更快，迭代周期更短
单体应用被分解成多个更小的服务，每个服务有自己的归档文件，单独部署，然后共同组成一个应用程序
微服务有如下优点：
微服务是松藕合的，无论是在开发阶段或部署阶段都是独立的。
能够快速响应, 局部修改容易, 一个服务出现问题不会影响整个应用。
易于和第三方应用系统集成, 支持使用不同的语言开发, 允许你利用融合最新技术。
每个微服务都很小，足够内聚，足够小，代码容易理解。团队能够更关注自己的工作成果, 聚焦指定的业务功能或业务需求。
开发简单、开发效率提高，一个服务可能就是专一的只干一件事, 能够被小团队单独开发，这个小团队可以是 2 到 5 人的开发人员组成。
同样的, 也存在如下缺点:
微服务架构带来过多的运维操作, 可能需要团队具备一定的 DevOps 技巧.
分布式系统可能复杂难以管理。因为分布部署跟踪问题难。当服务数量增加，管理复杂性增加。

单块架构应用：功能集中，代码和数据中心化，一个发布包部署后运行在同一个进程中的应用程序
优点
开发简单直接，集中式管理, 基本不会重复开发
功能都在本地，没有分布式的管理开销和调用开销。
缺点
开发效率低：所有的开发在一个项目改代码，递交代码相互等待，代码冲突不断
代码维护难：代码功能耦合在一起，新人不知道何从下手
部署不灵活：构建时间长，任何小修改必须重新构建整个项目，这个过程往往很长
稳定性不高：一个微不足道的小问题，可以导致整个应用挂掉
扩展性不够：无法满足高并发情况下的业务需求


八、HTTP
3. 介绍一下 https
客户端              服务端
第一步：客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
第二步：Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
第三步：客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
第四步：客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
第五步：Web服务器利用自己的私钥解密出会话密钥。
第六步：Web服务器利用会话密钥加密与客户端之间的通信。

对称加密：加解密使用同一个密钥
非对称加密:加解密使用不同的密钥

RPC协议与HTTP协议的区别

1、RPC是一种API，HTTP是一种无状态的网络协议。RPC可以基于HTTP协议实现，也可以直接在TCP协议上实现。
2、RPC主要是用在大型网站里面，因为大型网站里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。
HTTP主要是用在中小型企业里面，业务线没那么繁多的情况下。
3、HTTP开发方便简单、直接。开发一个完善的RPC框架难度比较大。
4、HTTP发明的初衷是为了传送超文本的资源，协议设计的比较复杂，参数传递的方式效率也不高。开源的RPC框架针对远程调用协议上的效率会比HTTP快很多。
5、HTTP需要事先通知，修改Nginx/HAProxy配置。RPC能做到自动通知，不影响上游。
6、HTTP大部分是通过Json来实现的，字节大小和序列化耗时都比Thrift要更消耗性能。RPC，可以基于Thrift实现高效的二进制传输。

TCP UDP区别
TCP 是面向连接的，UDP 是面向无连接的
UDP程序结构较简单
TCP 是面向字节流的，UDP 是基于数据报的
TCP 保证数据正确性，UDP 可能丢包
TCP 保证数据顺序，UDP 不保证

OSI七层模型
应用层   HTTP,FTP,TFTP,SMTP
表示层
会话层      
传输层   TCP,UDP
网络层   IP,ICMP,ARP,BARP,AKP,UUCP
数据链路层 FDDI,PPP
物理层   IEEE


网络编程

TCP建立连接和断开连接的过程？
三次握手
客户端发送 SYN=1,seq=j
服务端返回 ACK=1,ack=j+1,SYN=1,seq=k
客户端接收发送 ACK=1,ack=k+1
四次挥手
客户端发送 FIN=1,seq=m
服务端返回 ACK=1,ack=m+1
服务端发送 FIN=1,seq=n
客户端返回 ACK=1,ack=n+1


HTTP协议的交互流程，HTTP和HTTPS的差异，SSL的交互流程？

TCP的滑动窗口协议有什么用？

HTTP协议都有哪些方法？
Socket交互的基本流程？
讲讲tcp协议（建连过程，慢启动，滑动窗口，七层模型）？
webservice协议（wsdl/soap格式，与restt办议的区别）？
说说Netty线程模型，什么是零拷贝？

DNS解析过程？

TCP如何保证数据的可靠传输的？

八、分布式

什么是CAP定理？
C 一致性 A 可用性 P 分区容错性 三者只能满足其二
可用性针对节点出现故障，系统可用；分区容错性针对网络出现问题，系统可用
在分布式系统中，网络异常是不可避免的，所以如果不保证分区容错性，除非节点间网络不会发生异常，这个是不可能的（除非单机系统，单机系统就不是分布式系统）。
分布式系统肯定要实现P
1、Redis中间件 ―-> AP
2、RocketMQ中间件 ―C> AP
3、分布式事务-2pc ―-> CP
4、分布式事务-最大努力尝试 ―> AP
5、Eureka ―> AP

说说CAP理论和BASE理论？
BASE是对CAP的延申
基本可用，软状态，最终一致性

什么是最终一致性？最终一致性实现方式？
数据一致性的协议
两阶段提交协议 准备-->提交，基于事务管理器
三阶段提交协议 事务处理能力询问-->处理后待提交-->提交确认，引入了超时机制
TCC协议 Try commit cancle  基于业务逻辑
Paxos协议
ZAB协议
Raft协议
Quorum协议
Gossip协议
基于消息的最终一致性，失败重试，对账处理
GTS(阿里巴巴开源组件）

什么是一致性Hash？
把服务器ip映射到一个hash环，ip点少的时候会造成hash倾斜（一种加机器（成本高）二种加虚拟节点
计算用户请求的hash值，然后顺时针找最近的一个IP，
单调性
分散性
平衡性

讲讲分布式事务？
如何实现分布式锁？
如何实现分布式 Session?

如何保证消息的一致性?
生产者到MQ:通过ACK确认
MQ对消息持久化
MQ发送给消费者：通过ACK确认
MQ对消息删除

负载均衡的理解？
轮询，随机，HASH,最小连接，最快相应时间

正向代理和反向代理？
正向代理:服务端不知道真实的客户端是谁
反向代理:客户端不知道真实的服务端是谁

CDN实现原理？
怎么提升系统的QPS和吞吐？
Dubbo的底层实现原理和机制？
client发起一个请求，生成一个唯一标识ID,将方法参数，接口，callback对象封装成一个Object对象
放入到concurrentHashMap(id,Object),然后把Id,接口，方法参数封装成request请求对象到服务端
同时调用callback.get(),如果获取不到，就同步等待，调用callback.wait()
服务处理完成之后返回，通过监听程序：取到返回ID，通过ID，获取对应的callback对象，调用Notify通知

描述一个服务从发布到被消费的详细过程？
分布式系统怎么做服务治理？
消息中间件如何解决消息丢失问题？
Dubbo的服务请求失败怎么处理？
对分布式事务的理解？
如何实现负载均衡,有哪些算法可以实现?
Zookeeper的用途,选举的原理是什么?
讲讲数据的垂直拆分水平拆分？
zookeeper原理和适用场景？
zookeeper watch机制？
redis/zk节点宕机如何处理？

分布式集群下如何做到唯一序列号？
数据库自增，uuid,redis incr,zookeeper

用过哪些MQ,怎么用的,和其他mq比较有什么优缺点,MQ的连接是线程安全的吗？
MQ系统的数据如何保证不丢失？

列举出能想到的数据库分库分表策略？
垂直拆分 （按模块)
水平拆分 （按列）
说说分布式缓存和一致性哈希？

系统内核层面
同步I/O 异步I/O
用户空间和内核空间
进程切换
进程的阻塞
文件描述符
缓存 I/O

- 阻塞 I/O（blocking IO） 两部1将数据拷贝到kernel 2将数据从kernel拷贝到用户内存 两个阶段都被block
- 非阻塞 I/O（nonblocking IO） 用户发起read操作时候，kernel会立刻返回给用户error或者结果，用户需要不断轮询
- I/O 多路复用（ IO multiplexing） 事件驱动模型 select,poll,epoll,单个process可以处理多个I/O，epoll会不断轮询所有的socket，当某个socket有数据到达，就通知用户进程
当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，
select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。
I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。

- 信号驱动 I/O（ signal driven IO）
- 异步 I/O（asynchronous IO）

九、Mybatis

MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架，其主要就完成2件事情：

封装JDBC操作
利用反射打通Java类与SQL语句之间的相互转换

MyBatis的主要成员

Configuration        MyBatis所有的配置信息都保存在Configuration对象之中，配置文件中的大部分配置都会存储到该类中
SqlSession            作为MyBatis工作的主要顶层API，表示和数据库交互时的会话，完成必要数据库增删改查功能
Executor               MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护
StatementHandler 封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数等
ParameterHandler  负责对用户传递的参数转换成JDBC Statement 所对应的数据类型
ResultSetHandler   负责将JDBC返回的ResultSet结果集对象转换成List类型的集合
TypeHandler          负责java数据类型和jdbc数据类型(也可以说是数据表列类型)之间的映射和转换
MappedStatement  MappedStatement维护一条<select|update|delete|insert>节点的封装
SqlSource              负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回
BoundSql              表示动态生成的SQL语句以及相应的参数信息

是将mybatis和spring进行整合开发，事务控制在service中,service结束，sqlSession就关闭


l
https://github.com/AobingJava/JavaFamily

十、基础

基础类型跟包装类型区别
1.包装类型可以为NULL,在POJO里面最好定义包装类型
2.包装类型可用于泛型，而基本类型不可以
3.基本类型比包装类型更高效
基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用
自动拆箱装箱 .valueOf() invValue()

十一、数据结构、算法

如何判断链表有环
快慢指针
循环判断是否有重复节点

如何判断两个单链表是否相交
使用栈
判断两个链表的最后一个节点是否相等
