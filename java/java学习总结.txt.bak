一、并发编程：

什么是多线程并发和并行？ 
并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生

什么是线程安全问题？ 
多个线程在操作同一个共享变量的时候，预期结果和实际结果不一致。

什么是共享变量的内存可见性问题？ 
每个线程都有自己的私有内存空间（栈），线程启动后会把共享变量的值从共享内存拷贝一份到私有内存，并且再修改之后再push到共享内存，

什么是Java中原子性操作？
不会被线程调度机制打断的操作，一旦开始就不会被打断，一直到结束。

什么是Java中的CAS操作,AtomicLong实现原理？
比较并交换，内存值V,预期原值A,新值B,只有A=V的时候，才将V设置为B

什么是Java指令重排序？
在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序 分三种 编译优化的重排序，指令级并行的重排序，内存系统的重排序

Java中Synchronized关键字的内存语义是什么？
synchronized 具有使每个线程依次排队操作共享变量的功能 原子性（只能被一个线程访问），可见性，有序性（只能被一个线程访问）

Java中Volatile关键字的内存语义是什么？
写的时候会把值刷新到主内存，读的时候把本地缓存清空，从主内存读取共享变量的值 可见性 有序性

什么是伪共享,为何会出现，以及如何避免？
当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享

什么是可重入锁、乐观锁、悲观锁、公平锁、非公平锁、独占锁、共享锁？
可重入锁 可以多次获取同一把锁
乐观锁 不锁住对象
悲观锁 锁住对象
公平锁 需要排队
非公平锁 不需要排队
独占锁 每次只能由一个线程占用
共享锁 可以被多个线程共有

讲讲ThreadLocal 的实现原理？ThreadLocal 作为变量的线程隔离方式，其内部是如何做的？
Thread对象有一个ThreadLocalMap对象，key就是ThreadLocal,value可以任意值，以空间换时间，每个线程独自拥有一个变量，是隔离的

说说InheritableThreadLocal 的实现原理？
InheritableThreadLocal 是如何弥补 ThreadLocal 不支持继承的特性？

CyclicBarrier内部的实现与 CountDownLatch 有何不同？
CyclicBarrier主要基于ReentrantLock 以及 Condition 的共享唤醒线程，parties，count，每次调用await()方法时count-1，如果不等于0，
调用condition.await()方法阻塞等待，如果等于0，则调用condition.signalAll()方法唤醒所有线程执行，同时count = parties,可重用
CountDownLatch主要基于AQS实现，初始化state，每次调用coundDown()，state减1，直到减为0时，调用await()唤醒所有线程。

随机数生成器 Random 类如何使用 CAS 算法保证多线程下新种子的唯一性？
通过AtomicLong的compareAndSet来实现旧的种子跟新的种子的切换，来保证新种子的唯一性

ThreadLocalRandom 是如何利用 ThreadLocal 的原理来解决 Random 的局限性？
RANDOM是CAS操作，多个线程公用一个种子，会降低并发性能，ThreadLocalRandom实现了每个线程有自己单独的种子，提高性能

Spring 框架中如何使用 ThreadLocal 实现 request scope 作用域 Bean？

并发包中锁的实现底层（对AQS的理解）？

讲讲独占锁 ReentrantLock 原理？
CAS+CLH队列来实现,state从0开始


谈谈读写锁 ReentrantReadWriteLock 原理？
state是int类型，共32位，
读锁用高16位，表示持有读锁的线程数（sharedCount）
写锁用低16位，表示写锁的重入次数 （exclusiveCount）
状态值为 0 表示锁空闲，读锁可连续获取多个，写锁只能在没有任何读写时才能获取，写锁的线程可获取当前线程的读锁，读锁获取时如果有写锁在队列等待，该读锁也必须入队。

StampedLock 锁原理的理解？

谈下对基于链表的非阻塞无界队列 ConcurrentLinkedQueue 原理的理解？
tail,head
入队时有两种操作：
1、如果tail.next为空，将入队节点设置成尾节点的下一个节点
2、如果tail的next不为空，将入队节点设置成tail节点
ConcurrentLinkedQueue 内部是如何使用 CAS 非阻塞算法来保证多线程下入队出队操作的线程安全？

基于链表的阻塞队列 LinkedBlockingQueue 原理。
基于ReentrantLock 实现，定义了两个ReentrantLock对象一个takeLock，一个putLock，两个condition配合takeLock,putLock
阻塞队列LinkedBlockingQueue 内部是如何使用两个独占锁 ReentrantLock 以及对应的条件变量保证多线程先入队出队操作的线程安全？

分析下JUC 中倒数计数器 CountDownLatch 的使用与原理？
基于AQS实现共享锁实现，初始化state，调用countdown时候，cas方法state减1，调用await()阻塞等待
一个或者多个线程等待一组线程执行完毕，必须等所有运动员跑到终点才可以发布成绩（可以设置超时时间）
CountDownLatch 与线程的 Join 方法区别是什么？
thread.join() 方法必须等thread 执行完毕，才能向下执行
CountDownLatch 则只要计数器为0，就可以继续执行

讲讲对JUC 中回环屏障 CyclicBarrier 的使用？
让一组线程等待某个事件发生，才能继续执行，所有运动员等待枪响才可以开始跑步，

CyclicBarrier内部的实现与 CountDownLatch 有何不同？
CountDownLath让等待的线程不阻塞，CyclicBarrier让线程阻塞，可重用

Semaphore 的内部实现是怎样的？
限定线程并发数量，基于AQS实现，有公平模式和非公平模式

并发组件CopyOnWriteArrayList 是如何通过写时拷贝实现并发安全的 List？
写的时候把数据元素copy一份，通过ReetrantLock加锁，如果读取的时候读的是老数据，写入之后把list数组地址指向新的地址

同步与异步？阻塞与非阻塞？

1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。
2. 异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）
3. 阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。
4. 非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者

1、并发编程三要素？
原子性、可见性、有序性

2、实现可见性的方法有哪些？
锁
volatile

3、多线程的价值？
充分利用多核cpu的优势，效率高

3、创建线程的有哪些方式？
Threa,Runnable,Callable+Future

4.创建线程的三种方式的对比？

5、线程的状态流转图

6.Java线程具有五中基本状态

7.什么是线程池？有哪几种创建方式？

8.四种线程池的创建：

9.线程池的优点？

10.常用的并发工具类有哪些？

11.CyclicBarrier和CountDownLatch的区别

12.synchronized的作用？

13.volatile关键字的作用

14.什么是CAS

15. CAS的问题

16.什么是Future？

17.什么是AQS

18. AQS支持两种同步方式：

19.ReadWriteLock是什么

20.FutureTask是什么

21.synchronized和ReentrantLock的区别

22.什么是乐观锁和悲观锁

23.线程B怎么知道线程A修改了变量

24.synchronized、volatile、CAS比较

25.sleep方法和wait方法有什么区别?

26.ThreadLocal是什么？有什么用？

27.为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用

28.多线程同步有哪几种方法？

29.线程的调度策略

30.ConcurrentHashMap的并发度是什么

31.Linux环境下如何查找哪个线程使用CPU最长

32.Java死锁以及如何避免？

33.死锁的原因

34.怎么唤醒一个阻塞的线程

35.不可变对象对多线程有什么帮助

36.什么是多线程的上下文切换

37.如果你提交任务时，线程池队列已满，这时会发生什么

38.Java中用到的线程调度算法是什么

39.什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？

40.什么是自旋

41.Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？

42.单例模式的线程安全性

43.Semaphore有什么作用

44.Executors类是什么？

45.线程类的构造方法、静态块是被哪个线程调用的

46.同步方法和同步块，哪个是更好的选择?

47.Java线程数过多会造成什么异常？


二、JVM

Java 内存分配？
程序计数器，虚拟机栈，本地方法栈，堆，方法区
Java 堆的结构是什么样子的？
新生代（Eden,from/to） 1/3,老年代 2/3

什么是堆中的永久代（Perm Gen space）?
方法区，存储class、运行时常量池、字段、方法、代码、JIT代码等，是一个规范，规定了这个里面要存储什么东西
永久代是方法区的一个实现

说说各个区域的作用？
程序计数器(线程私有)：一个指针，指向下一条指令的地址，由执行引擎读取下一条指令，内存非常小，
本地方法栈(线程私有)：登记native方法，执行引擎执行时加载本地方法库，非java语言的方法
方法区(线程共享):所有定义方法的信息，静态变量+常量+类信息(构造方法/接口定义)
java栈(线程私有):java线程执行方法的内存模型，一个线程对应一个栈，每个方法执行时会创建一个栈帧（局部变量，操作数栈，动态链接，方法出库等），无垃圾回收，线程结束就释放


Java 中会存在内存泄漏吗，简述一下？
长生命周期的对象引用一个短生命周期的对象

Java 类加载过程？
加载：在硬盘上查找并通过IO读入字节码文件
验证：1、文件格式验证（class文件的格式规范）2、元数据验证（语法分析）3、字节码验证（语义分析）4、符号引用验证
准备：为类变量分配内存并且设置初始化值的，都在方法区分配，只初始化静态字段，并赋值初始化值（final类型的直接代码定义的值），不是代码的值
解析：虚拟机将符号引用转化为直接引用的过程，主要针对类或接口、类方法、接口方法、方法类型、方法句柄、字段以及调用点限定符等符号进行
初始化：执行java程序，初始化用户代码写的值
使用：
卸载

描述一下 JVM 加载 Class 文件的原理机制?
什么是类加载器？
动态的把类加载到jvm，就是把class文件从磁盘读取到内存中
类加载器有哪些？
启动类加载器、扩展类加载器、系统类加载器、用户自定义加载器
类加载器双亲委派模型机制？
先委托父类加载器寻找目标类，找不到的情况下在自己路劲下查找病载入目标类

什么是tomcat类加载机制？
启动类->扩展类->应用程序类->common类加载器（/common/*）->1、catalina类加载器（/server/*）2、shared类加载器->Webapp类加载器->jsp类加载器
tomcat是一个web容器，解决的问题
部署多个服务时，保证每个服务的同一个类的不同版本是隔离的，
相同的类库版本可以共享
自己依赖的类库要跟应用程序的隔离
支持jsp修改不重启
如果使用默认加载机制，无法加载两个相同类库的不同版本
每个jsp对应唯一一个类加载器，当jsp修改后，就卸载这个类加载器，重新创建一个类加载器，重新加载jsp文件


什么是GC? 为什么要有 GC？
GC就是垃圾回收，如果没有GC,使用对象的时候会一直占用内存空间，造成内存溢出
简述一下Java 垃圾回收机制？
在新生代分配对象时，如果不够分配，先执行一次minorGC，执行之后如果内存还不够用，
就去老年代申请，如果老年代也没有足够的内存就执行majroGC,如果GC之后内存还是不够就包内存溢出。

如何判断一个对象是否存活？
通过根节点是否可达

垃圾回收的优点和原理，并考虑 2 种回收机制？
防止内存泄露，有效使用内存，编写程序不需要考虑垃圾回收
标记清除，标记整理

垃圾回收器的基本原理是什么？
侦测java程序的运行情况，当发现有些对象可以回收时，就会销毁这些对象，并且释放内存
Serial收集器:串行，单线程，新生代复制算法，老年代标记整理 单cpu场景，单线程效率高
ParNew收集器:串行，多线程，新生代复制算法，老年代标记整理
Parallel Scavenge收集器:关注吞吐量，高效率利用CPU,新生代复制算法，老年代标记整理  jdk1.8默认新生代
Serial Old收集器:CMS收集器的后备方案
Parallel Old收集器:Parallel Scavenge的老年代版本，关注吞吐量  jdk1.8默认新生代
CMS收集器：主要老年代使用，并发收集，低停顿，标记-清除算法实现，
初始标记：暂停用户线程
并发标记：跟用户线程同时开启，
重新标记：处理并发标记自己，影响初始标记的，停顿时间比初始标记时间长
并发清除：并发未标记的区域做清扫
缺点：会抢CPU资源，无法处理浮动垃圾，并发标记产生的垃圾，产生不连续的内存碎片
G1收集器：既满足低停顿，又有高吞吐量
G1讲堆划分为多个大小相等的独立区域（region),Eden,Survivor,old,Humongous
region 大小一致，数值是在 1M 到 32M 字节之间的一个 2 的幂值数，JVM 会尽量划分 2048 个左右、同等大小的 region
新生代和老年代不在物理隔阂，大对象直接进去Humongous，不用进老年代，避免fullGC
region 大小和大对象很难保证一致，这会导致空间的浪费；特别大的对象是可能占用超过一个 region 的。
并且，region 太小不合适，会令你在分配大对象时更难找到连续空间，这是一个长久存在的情况。
优点：1、并行并发2、分代收集，空间整合：整体看是标记整理，局部看是复制，可预测的停顿
1、初始标记：与常规的年轻代相关，停顿
2、并发标记：在整个堆上标记，
3、最终标记：停顿
4、筛选回收：停顿
在后台维护了一个优先列表，根据允许的收集时间，优先选择回收价值最大的Region
YongGC ,MixedGc回收所用Yong和部分Old

垃圾回收器可以马上回收内存吗？
不会马上回收，只有在必须回收时候才会进行回收，因为占用cpu开销特别大
有什么办法主动通知虚拟机进行垃圾回收？
System.gc()。Runtime.getRuntime().gc()
System.gc() 和 Runtime.gc() 会做些什么？
提示垃圾回收器进行垃圾回收，但是立刻回收还是延时回收取决于jvm

深拷贝和浅拷贝？
浅拷贝仅仅复制所拷贝的对象，而不复制它所引用的对象
把要复制的对象所引用的对象都复制了一遍


什么是分布式垃圾回收（DGC）？它是如何工作的？
RMI子系统实现基于引用计数的分布式垃圾回收（DGC),
远程对象回收时必须本地没有应用，并且远程服务也没有引用，
客户端创建远程引用时，会在服务端DGC调用dirty(),完成使用后调用clean()方法，
从dirty()开始是租期时间，到期之前必须调用dirty()来续约，如果在租期到期前不续约，则分布式垃圾回收认定客户端不再应用远程对象

串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？
在 Java 中，对象什么时候可以被垃圾回收？
1、引用计数算法 2、可达性分析算法，GC roots是否可达
简述Minor GC 和 Major GC？
MinorGC新生代的GC，速度快，频率高
MajorGC老年代的GC,速度慢，频率低，一般至少会伴随一次minorGC,

Java 中垃圾收集的方法有哪些？
标记-清除：效率高，会产生大量不连续的碎片
标记-整理：先标记，然后让对象移动，再清楚，空间利用率高，效率慢
标记-复制：每次把存活对象复制到另一半，以空间换时间
分代收集：根据不同代采用不同算法

讲讲你理解的性能评价及测试指标？
停顿时间，吞吐量

常用的性能优化方式有哪些？
元空间大小，吞吐量大小，停顿时间参数，动态扩容增量，配置不同的收集器

什么是GC调优？
常见异步的手段有哪些？

三、Spring

为什么需要代理模式？
在不修改类的基础上，对类的功能附件与增强

讲讲静态代理模式的优点及其瓶颈？
程序可读性高，保证了业务类的重用性能，
代理对象的一个接口只服务一种类型的对象，如果要代理的方法很多，则需要写很多代码为每一个方法进行代理

对Java 接口代理模式的实现原理的理解？
实现InvocationHandler接口，
通过Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this)创建实例，

如何使用 Java 反射实现动态代理？
Java 接口代理模式的指定增强？

谈谈对Cglib 类增强动态代理的实现？

怎么理解面向切面编程的切面？
业务逻辑又进行了进一步的抽取，做成统一的服务，实现代码复用

讲解OOP与AOP的简单对比？
OOP主要针对业务

讲解JDK 动态代理和 CGLIB 代理原理以及区别？
对接口自动生成代理类
对类生成子类的方式实现代理

讲解Spring 框架中基于 Schema 的 AOP 实现原理？

讲解Spring 框架中如何基于 AOP 实现的事务管理？

谈谈对控制反转的设计思想的理解？

怎么理解 Spring IOC 容器？

Spring IOC 怎么管理 Bean 之间的依赖关系，怎么避免循环依赖？
三级缓存
singletonObjects：单例对象的cache 一级
earlySingletonObjects ：提前暴光的单例对象的Cache 。【用于检测循环引用，与singletonFactories互斥】 二级
singletonFactories ： 单例对象工厂的cache  三级
能解决setter方式注入，不能解决构造器注入
A先完成初始化第一步，然后将自己提前曝光到三级缓存里面，
B初始化，从一级找，找不到A,从二级找找不到A,从三级找找到A,然后初始化完毕，


对Spring IOC 容器的依赖注入的理解？
应用程序依赖spring容器注入某个应用程序的某个对象

说说对Spring IOC 的单例模式和高级特性？

BeanFactory 和 FactoryBean 有什么区别？
BeanFactory是个Factory，也就是IOC容器或对象工厂，FactoryBean是个Bean。在Spring中，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的。
但对FactoryBean而言，这个Bean不是简单的Bean，而是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似 

BeanFactory 和 ApplicationContext 又有什么不同？
ApplicationContext接口,它由BeanFactory接口派生而来，ApplicationContext包含BeanFactory的所有功能

谈谈Spring Bean 创建过程中的设计模式？
spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象

SrpingBean的生命周期
实例化：构造器注入或者简单实例化
设置bean的Aware：BeanNameAware，BeanClassLoaderAware，ResourceLoaderAware,ApplicationContextAware,BeanFactoryAware
BeanPostProcessor.postProcessBeforeInitialization(Object bean, String beanName) 后置处理器在初始化之前的工作
InitializingBean.afterPorpertiesSet     bean的属性设置
BeanPostProcessor.postProcessAfterInitialization(Object bean, String beanName)  后置处理器在初始化之后的工作
SmartInitializingSingleton.afterSingletonsInstantiated 单例bean在初始化之后的设置
SmartLifecycle.start 生命周期开始
bean已经在spring容器的管理下，可以做我们想做的事
SmartLifecycle.stop(Runnable callback) 生命周期停止
DisposableBean.destroy() bean销毁

Spring AOP / AspectJ AOP 的区别？
Spring AOP属于运行时增强，而AspectJ是编译时增强。
Spring AOP基于代理（Proxying），
而AspectJ基于字节码操作（Bytecode Manipulation）。AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。如果切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多。




四、数据库 
https://cloud.tencent.com/developer/article/1469131

interactive_timeout = 1800 交互式链接超时时间（通过mysql客户端）
wait_timeout = 1800 非交互式链接超时时间（通过jdbc链接）

MySQL 有哪些存储引擎啊？都有什么区别？
MyIsam
InnoDB 支持事务，行级锁，外键
MyISAM 不支持事务，表级锁，保持表的行数

Float、Decimal 存储金额的区别？
Float只保存6位，

Datetime、Timestamp 存储时间的区别？
Timestamp转化为UTC存储，查询时又反转，Datetime不变
存储范围不一致，Timestamp只能存储到1970-2038年，Datetime存储1000到9999

Char、Varchar、Varbinary 存储字符的区别？
char使用固定长度的空间进行存储，经常改变的值，char优于varchar，原因是固定长度的行不容易产生碎片，自动去空格
varchar保存可变长度的字符串，使用额外的一个或两个字节存储字符串长度
Varbinary保存的是字节

对比一下B+树索引和 Hash索引？

MySQL索引类型有？
HASH,BTRee


如何管理 MySQL索引？
对Explain参数及重要参数的理解？
1、ID:是否有子查询，值越大优先级越高
2、select_type:查询类型
simple:简单的select查询,查询中不包含子查询或union查询
primary:查询中若包含任何复杂的子部分,最外层查询则被标记为primary
subquery 在select 或where 列表中包含了子查询
derived 在from列表中包含的子查询被标记为derived,mysql会递归这些子查询,把结果放在临时表里
union 做第二个select出现在union之后,则被标记为union,若union包含在from子句的子查询中,外层select将被标记为derived
union result 从union表获取结果的select
3、table:显示一行的数据时关于哪张表的
4、type:从最好到最差依次是:system>const>eq_ref>ref>range>index>All
system:表只有一行记录,这是const类型的特例,平时不会出现
const:表示通过索引一次就找到了,const即常量,它用于比较primary key或unique索引,因为只匹配一行数据,所以效率很快,如将主键置于where条件中,mysql就能将该查询转换为一个常量
eq_ref:唯一性索引扫描,对于每个索引键,表中只有一条记录与之匹配,常见于主键或唯一索引扫描
ref:非唯一性索引扫描,返回匹配某个单独值的行,它可能会找到多个符合条件的行,所以他应该属于查找和扫描的混合体
range:只检索给定范围的行,使用一个索引来选择行,如where语句中出现了between,<,>,in等查询,
这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。
index:index类型只遍历索引树,这通常比All快,因为索引文件通常比数据文件小,index是从索引中读取,all从硬盘中读取
all:全表扫描,是最差的一种查询类型
5、possible_keys:显示可能应用在这张表中的索引,一个或多个,查询到的索引不一定是真正被用到的
6、key:实际使用的索引,如果为null,则没有使用索引,因此会出现possible_keys列有可能被用到的索引,但是key列为null,表示实际没用索引。
7、key_len:表示索引中使用的字节数,而通过该列计算查询中使用的 索引长度,在不损失精确性的情况下,长度越短越好,
key_len显示的值为索引字段的最大可能长度,并非实际使用长度,即,key_len是根据表定义计算而得么不是通过表内检索出的
8、ref显示索引的哪一列被使用了,如果可能的话是一个常数,哪些列或常量被用于查找索引列上的值
9、rows根据表统计信息及索引选用情况,大只估算出找到所需的记录所需要读取的行数
10、Extra
Using filesort:说明mysql会对数据使用一个外部的索引排序,而不是按照表内的索引顺序进行读取,mysql中无法利用索引完成的排序操作称为"文件排序"
Using temporary :使用了临时表保存中间结果,mysql在对查询结果排序时使用临时表,常见于order by和分组查询group by
Using index:表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。如果同时出现using where，
表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。 其中的覆盖索引含义是所查询的列是和建立的索引字段和个数是一一对应的
Using where:表明使用了where过滤
Using join buffer:表明使用了连接缓存,如在查询的时候会有多次join,则可能会产生临时表
impossible where:表示where子句的值总是false,不能用来获取任何元祖


索引利弊是什么及索引分类？
增加存储空间，更新增加IO消耗
种类：普通索引，唯一索引，主键索引，组合索引，全文索引

聚簇索引和非聚簇索引的区别？
聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
非聚簇索引：索引与数据分开存储

B+tree 如何进行优化？索引遵循哪些原则？

索引与锁有什么关系？
InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁

还有什么其他的索引类型，各自索引有哪些优缺点？

谈谈对Innodb事务的理解？
A原子性 C一致性 I隔离性 D持久性
ACD通过redo log(重做日志)和(Undo log)实现，隔离性通过锁来实现
Redo log 物理日志
重做日志用来实现事务的持久性，即D特性。它由两部分组成：
①内存中的重做日志缓冲
②重做日志文件
Undo log 逻辑日志
实现事务回滚
实现mvcc

说说数据库事务特点及潜在问题？

什么是MySQL隔离级别？
读未提交  脏读，不可重复读，幻读
读已提交  不可重复读，幻读
可重复读  幻读
串行化

1、事务隔离级别为读提交时，写数据只会锁住相应的行
2、事务隔离级别为可重复读时，如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key 锁；如果检索条件没有索引，
更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。
、事务隔离级别为串行化时，读写数据都会锁住整张表


有多少种事务失效的场景，如何解决？
Transactional的异常控制，默认是Check Exception 不回滚，unCheck Exception回滚

一致性非锁定读和一致性锁定读是什么？
一致性非锁定读指的是：要读取的行被加了X锁（排它锁），这时候读取操作不会等待行上锁的释放，而是会读取行的一个快照数据
行记录可能有多个版本
在RC下读取的是最新的一份快照数据，在RR下读取的是事务开始的数据版本
一致性锁定读在事务读取时就把记录锁住 for update, lock in share mode


表级锁分为读锁和写锁
读锁：LOCK TABLE table_name [ AS alias_name ] READ
申请前提是没有其它线程对该表使用写锁，申请之后其它线程可以执行读操作，不能执行写操作
写锁：LOCK TABLE table_name [AS alias_name] [ LOW_PRIORITY ] WRITE
可以指定优先级，

行级锁：锁粒度最细的一种锁，减少数据库操作的冲突，分为共享锁和排他锁
共享锁(S LOCK): SELECT ...LOCK IN SHARE MODE;
mysql会对查询结果的每行都加共享锁，没有其他线程对查询结果的任何一行使用排他锁时，可以成功申请共享锁，
排他锁(X LOCK)：SELECT ...LOCK FOR UPDATE;
mysql会对查询结果的每行都加排他锁，没有其他线程对查询结果的任何一行使用排他锁时，可以成功申请排他锁，
行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。行级锁的缺点是：由于需要请求大量的锁资源，所以速度慢，内存消耗大

死锁：死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象，若无外力作用,它们都将无法推进下去.
产生条件：
互斥条件-指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放
请求和保持条件-指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放
不可剥夺条件-指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放
环路等待条件-指在发生死锁时，必然存在一个进程――资源的环形链，即进程集合{P0，P1，P2，・・・，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源

死锁避免的基本思想：系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，如果分配后系统可能发生死锁，则不予分配，否则予以分配，
这是一种保证系统不进入死锁状态的动态策略。 如果操作系统能保证所有进程在有限时间内得到需要的全部资源，则系统处于安全状态否则系统是不安全的。
有序资源分配法
1、对它所必须使用的而且属于同一类的所有资源，必须一次申请完；
2、在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。
银行家算法

Innodb如何解决幻读？
多版本并发控制（MVCC)
每一行都冗余了两个字段，一个是行的创建版本，一个是行的删除版本
版本号存在information_schema.INNODB_TRX表中
版本号（trx_id）随着每次事务开启自增
每次取的时候取创建版本小于当前的版本，删除版本大于当前的版本

死锁及监控是什么？
自增长与锁：轻量级互斥量的自增长实现机制
锁的算法，锁问题，锁升级是什么？

乐观锁的线程如何做失败补偿？
1、消息队列处理
2、aop(自定义异常，更新失败抛出异常，重试）

谈谈MySQL的锁并发？
查询优化的基本思路是什么？
explain查看执行计划

说说MySQL读写分离、分库分表？
表结构对性能有什么影响?
浅谈索引优化？
说说Sql优化的几点原则？
MySQL表设计及规范？
说说MySQL几种存储引擎应用场景？
MySQL常用优化方式有哪些？

MySQL常用监控？
指标分类	指标名称	指标说明
性能类指标	QPS	数据库每秒处理的请求数量
		TPS	数据库每秒处理的事务数量
		并发数	数据库实例当前并行处理的会话数量
		连接数	连接到数据库会话的数量
		缓存命中率	查询命中缓存的比例
高可用指标	可用性	数据库是否可以正常对外服务
		阻塞	当前阻塞的会话数
		慢查询	慢查询情况
		主从延迟	主从延迟时间
		主从状态	主从链路是否正常
		死锁	查看死锁信息

MySQL瓶颈分析？

mysql的两个机制
半同步复制，用来解决主库数据丢失问题 通过从库ack确认
并行复制，解决同步延时问题 从库开启多个并行读取relay 
log中不同库的日志，并行重放不同库的日志，库级别的并行

五、redis

redis数据结构有哪些？
string,list,set,zset,hash

Redis缓存穿透，缓存雪崩？
缓存穿透：恶意用户模拟请求许多缓存中不存在的数据，导致请求落库，造成数据库异常
解决方案：1使用互斥锁排队 2、接口限流、熔断、降级  3、布隆过滤器

如何使用Redis来实现分布式锁？
redis.setnx expire

Redis的并发竞争问题如何解决？
利用redis自带的incr命令
使用乐观锁的方式
在客户端加锁

Redis持久化的几种方式，优缺点是什么，怎么实现的？
RDB,定时讲数据dump到磁盘上，fork一个子进程，讲数据写入临时文件，不会保存过期的键值,全量持久化
AOF 记录日志 ，增量持久化

Redis的缓存失效策略？
过期键删除策略:1、定期随机删除 2、惰性删除
内存淘汰机制：
volatile-lru ：在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把 redis 既当缓存，又做持久化存储的时候才用
allkeys-lru ： 移除最近最少使用的key （推荐）
volatile-random ： 在设置了过期时间的键空间中，随机移除一个键，不推荐
allkeys-random ： 直接在键空间中随机移除一个键
volatile-ttl ： 在设置了过期时间的键空间中，有更早过期时间的key优先移除 不推荐
noeviction ： 不做过键处理，只返回一个写操作错误。 不推荐


Redis集群，高可用，原理？
(1).Redis 集群的分片特征在于将键空间分拆了16384个槽位，每一个节点负责其中一些槽位。 
(2).Redis提供一定程度的可用性,可以在某个节点宕机或者不可达的情况下继续处理命令. 
(3).Redis 集群中不存在中心(central)节点或者代理(proxy)节点， 集群的其中一个主要设计目标是达到线性可扩展性(linear scalability)

 集群的使用公式HASH_SLOT=CRC16(key) mod 16384 计算key属于哪个槽

redis队列应用场景？
lpush,lpop,rpush,rpop

分布式使用场景（储存session）？
session,分布式锁

Redis主要有哪些功能？

Redis是单进程单线程的？
单线程

Redis为什么是单线程的？
内存数据库，
单线程减少上下文切换，
核心是基于非阻塞的 IO 多路复用机制
redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型
文件事件处理器的结构包含 4 个部分：
多个 socket
IO 多路复用程序
文件事件分派器
事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，
会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理

其它开源软件采用的模型

使用Redis的优势？

Redis单点吞吐量
qps 10万/秒 tps 8万/秒

Redis相比memcached有哪些优势？
redis 支持复杂的数据结构
redis 原生支持集群模式
redis 支持持久化
redis 单线程性能更好


Redis集群方案应该怎么做？都有哪些方案？
客户端分片
codis
原生集群

Redis读写分离模型

Redis常见性能问题和解决方案？

Redis支持的Java客户端都有哪些？官方推荐用哪个？
Redisson,Jedis，lettuce

Redis集群的主从复制模型是怎样的？

Redis集群会有写操作丢失吗？为什么？

Redis集群之间是如何复制的？

Redis如何做内存优化？

Redis回收进程如何工作的？

Redis回收使用的是什么算法？

Redis有哪些适合的场景？


六、MQ
1. 为什么使用 MQ, MQ 如何选型, 消息可靠性如何保证, 如何保证幂等
mq 消息可靠性,幂等如何保证
MQ作用
1、异步
2、解耦
3、削峰
缺点：系统可用性降低、复杂度增高
选型
特性	     ActiveMQ	RabbitMQ	RocketMQ	kafka
开发语言	java	erlang	        java	        scala
单机吞吐量	万级	万级	        10万级	        10万级
时效性	        ms级	us级	        ms级	        ms级以内
可用性	高(主从架构)	高(主从架构)	非常高(分布式架构)	非常高(分布式架构)
功能特性	
成熟的产品，在很多公司得到应用；有较多的文档；各种协议支持较好	
基于erlang开发，所以并发能力很强，性能极其好，延时很低;管理界面较丰富	
MQ功能比较完备，扩展性佳	
只支持主要的MQ功能，像一些消息查询，消息回溯等功能没有提供，毕竟是为大数据准备的，在大数据领域应用广。
RabbitMQ消息可靠性保证
1生产者 transaction 或者 confirm 
2消息队列丢失数据 queue持久化 消息持久化
3消费者丢失数据 关闭自动 ack，手动ack

ExchangeTypes
fanout direct topic
binding key 把exchange和queue关系确定
routing key 到queue

七、RPC
2. 用过 dubbo吗? 
dubbo四大组件
Provider：提供者
Consumer：消费者
registry：注册中心（相当于中介）
monitor：监控中心
container：服务容器
设计一个 rpc 框架.

HTTP
3. 介绍一下 https
客户端              服务端
第一步：客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。
第二步：Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。
第三步：客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。
第四步：客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
第五步：Web服务器利用自己的私钥解密出会话密钥。
第六步：Web服务器利用会话密钥加密与客户端之间的通信。

对称加密：加解密使用同一个密钥
非对称加密:加解密使用不同的密钥

RPC协议与HTTP协议的区别

1、RPC是一种API，HTTP是一种无状态的网络协议。RPC可以基于HTTP协议实现，也可以直接在TCP协议上实现。
2、RPC主要是用在大型网站里面，因为大型网站里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。
HTTP主要是用在中小型企业里面，业务线没那么繁多的情况下。
3、HTTP开发方便简单、直接。开发一个完善的RPC框架难度比较大。
4、HTTP发明的初衷是为了传送超文本的资源，协议设计的比较复杂，参数传递的方式效率也不高。开源的RPC框架针对远程调用协议上的效率会比HTTP快很多。
5、HTTP需要事先通知，修改Nginx/HAProxy配置。RPC能做到自动通知，不影响上游。
6、HTTP大部分是通过Json来实现的，字节大小和序列化耗时都比Thrift要更消耗性能。RPC，可以基于Thrift实现高效的二进制传输。

TCP UDP区别
TCP 是面向连接的，UDP 是面向无连接的
UDP程序结构较简单
TCP 是面向字节流的，UDP 是基于数据报的
TCP 保证数据正确性，UDP 可能丢包
TCP 保证数据顺序，UDP 不保证

OSI七层模型
应用层   HTTP,FTP,TFTP,SMTP
表示层
会话层      
传输层   TCP,UDP
网络层   IP,ICMP,ARP,BARP,AKP,UUCP
数据链路层 FDDI,PPP
物理层   IEEE


网络编程

TCP建立连接和断开连接的过程？
三次握手
客户端发送 SYN=1,seq=j
服务端返回 ACK=1,ack=j+1,SYN=1,seq=k
客户端接收发送 ACK=1,ack=k+1
四次挥手
客户端发送 FIN=1,seq=m
服务端返回 ACK=1,ack=m+1
服务端发送 FIN=1,seq=n
客户端返回 ACK=1,ack=n+1


HTTP协议的交互流程，HTTP和HTTPS的差异，SSL的交互流程？
TCP的滑动窗口协议有什么用？
HTTP协议都有哪些方法？
Socket交互的基本流程？
讲讲tcp协议（建连过程，慢启动，滑动窗口，七层模型）？
webservice协议（wsdl/soap格式，与restt办议的区别）？
说说Netty线程模型，什么是零拷贝？

DNS解析过程？

TCP如何保证数据的可靠传输的？

八、分布式

什么是CAP定理？
C 一致性 A 可用性 P 分区容错性 三者只能满足其二
说说CAP理论和BASE理论？
BASE是对CAP的延申
基本可用，软状态，最终一致性

什么是最终一致性？最终一致性实现方式？
数据一致性的协议
两阶段提交协议 准备-->提交，基于事务管理器
三阶段提交协议 事务处理能力询问-->处理后待提交-->提交确认，引入了超时机制
TCC协议 Try commit cancle  基于业务逻辑
Paxos协议
ZAB协议
Raft协议
Quorum协议
Gossip协议
基于消息的最终一致性，失败重试，对账处理

什么是一致性Hash？
把服务器ip映射到一个hash环，ip点少的时候会造成hash倾斜（一种加机器（成本高）二种加虚拟节点
计算用户请求的hash值，然后顺时针找最近的一个IP，
单调性
分散性
平衡性

讲讲分布式事务？
如何实现分布式锁？
如何实现分布式 Session?

如何保证消息的一致性?
生产者到MQ:通过ACK确认
MQ对消息持久化
MQ发送给消费者：通过ACK确认
MQ对消息删除

负载均衡的理解？
轮询，随机，HASH,最小连接，最快相应时间

正向代理和反向代理？
正向代理:服务端不知道真实的客户端是谁
反向代理:客户端不知道真实的服务端是谁

CDN实现原理？
怎么提升系统的QPS和吞吐？
Dubbo的底层实现原理和机制？
client发起一个请求，生成一个唯一标识ID,将方法参数，接口，callback对象封装成一个Object对象
放入到concurrentHashMap(id,Object),然后把Id,接口，方法参数封装成request请求对象到服务端
同时调用callback.get(),如果获取不到，就同步等待，调用callback.wait()
服务处理完成之后返回，通过监听程序：取到返回ID，通过ID，获取对应的callback对象，调用Notify通知

描述一个服务从发布到被消费的详细过程？
分布式系统怎么做服务治理？
消息中间件如何解决消息丢失问题？
Dubbo的服务请求失败怎么处理？
对分布式事务的理解？
如何实现负载均衡,有哪些算法可以实现?
Zookeeper的用途,选举的原理是什么?
讲讲数据的垂直拆分水平拆分？
zookeeper原理和适用场景？
zookeeper watch机制？
redis/zk节点宕机如何处理？

分布式集群下如何做到唯一序列号？
数据库自增，uuid,redis incr,zookeeper

用过哪些MQ,怎么用的,和其他mq比较有什么优缺点,MQ的连接是线程安全的吗？
MQ系统的数据如何保证不丢失？

列举出能想到的数据库分库分表策略？
垂直拆分 （按模块)
水平拆分 （按列）
说说分布式缓存和一致性哈希？

系统内核层面
同步I/O 异步I/O
用户空间和内核空间
进程切换
进程的阻塞
文件描述符
缓存 I/O

- 阻塞 I/O（blocking IO） 两部1将数据拷贝到kernel 2将数据从kernel拷贝到用户内存 两个阶段都被block
- 非阻塞 I/O（nonblocking IO） 用户发起read操作时候，kernel会立刻返回给用户error或者结果，用户需要不断轮询
- I/O 多路复用（ IO multiplexing） 事件驱动模型 select,poll,epoll,单个process可以处理多个I/O，epoll会不断轮询所有的socket，当某个socket有数据到达，就通知用户进程
当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，
select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。
I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。

- 信号驱动 I/O（ signal driven IO）
- 异步 I/O（asynchronous IO）



1、Java事件机制包括哪三个部分？分别介绍。

2、为什么要使用线程池？

3、线程池有什么用？

4、说说几种常见的线程池及使用场景。

5、线程池都有哪几种工作队列？

6、怎么理解无界队列和有届队列？

7、线程池中的几种重要的参数及流程说明。

8、什么是反射机制？

9、说说反射机制的作用。

10、反射机制会不会有性能问题？

11、你怎么理解http协议？

12、说说http协议的工作流程。

13、http有哪些请求提交方式？

14、http中的200，302,403,404,500,503都代表什么状态？

15、http get和post有什么区别？

16、你怎么理解cookie和session，有哪些不同点？

17、什么是web缓存？有什么优点？

18、什么是https，说说https的工作原理？

19、什么是http代理服务器，有什么用？

20、什么是虚拟主机及实现原理？

21、什么是java虚拟机，我为什么要使用？

22、说说java虚拟机的生命周期及体系结构。

23、说一说java内存区域。

24、什么是分布式系统？

25、分布式系统你会考虑哪些方面？

26、讲一讲tcp协议的三次握手和四次握手流程。

27、为什么tcp建立连接协议是三次握手，而关闭连接确是四次握手呢？为什么不能用两次握手进行连接？

28、为什么tcp TIME-WAIT状态还需要等2MSL后才能返回到CLOSED状态？

29、什么是DoS、DDoS、DRDos攻击？如何防御？

30、描述一下Java异常层次结构。

31、什么是检查异常，不受检查异常，运行时异常？并分别举例说明。

32、Finally块一定会执行吗？

33、正常情况下，当在try块或catch块中遇到return语句时，finally语句在方法返回之前还是之后被执行？

34、Try、catch、finally语句块的执行顺序。

35、Java虚拟机中，数据类型可以分为哪几类？

36、怎么理解栈、堆？堆中存在什么？栈中存在什么？

37、为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？

38、在java中，什么是栈的起始点，同时也是程序的起始点？

39、为什么不把基本类型放堆中呢？

40、Java中的参数传递时传值呢?还是传引用？

41、Java中有没有指针的概念？

42、Java中，栈的大小通过什么参数来设置？

43、一个空Object对象的占多大空间？

44、对象引用类型分为那几类？

45、讲一讲垃圾回收算法。

46、如何解决内存碎片的问题？

47、如何解决同时存在的对象创建和对象回收问题？

48、讲一讲内存分代及生命周期。

49、什么情况下触发垃圾回收？

50、如何选择合适的垃圾收集算法？

51、JVM中最大堆大小有没有限制？

52、堆大小通过什么参数设置？

53、JVM有哪三种垃圾回收器？

54、吞吐量优先选择什么垃圾回收器？响应时间优先呢？

55、如何进行JVM调优？有哪些方法？

56、如何理解内存泄漏问题？有哪些情况会导致内存泄漏？如何解决？

57、从分布式系统部署角度考虑，分哪几层？

58、如何解决业务层的数据访问问题？

59、为了解决数据库服务器的负担。如何做数据库的分布？

60、什么是著名的拜占庭将军问题？

61、为什么说tcp/IP协议是不可靠的？

62、讲讲CAP理念。

63、怎么理解强一致性、单调一致性和最终一致性？

64、分布式系统设计你会考虑哪些策略？

65、最常见的数据分布式是什么？

66、谈一谈一致性哈希算法。

67、Paxos是什么？

68、什么是lease机制

69、如何理解选主算法？

70、OSI有哪七层模型？TCP/IP是哪四层模型。

71、Fabric在哪里做的共识，如何解决双花问题和节点伪造问题的，比如说A给B转账5元，给C同志1元劳务费，但是该节点作弊了怎么办？

72、拜占庭算法的理解？

73、TCP协议拥塞是怎么解决的？

74、JAVA虚拟机的理解？

75、JAVA线程池的参数都有什么？

76、有序链表和二叉搜索树在查找和插入上时间复杂度的区别？了解过红黑树么，在插入上有什么优化？

77、介绍下你觉得你做的比较好的项目，解决了哪些技术难点？

78、一个数组中有正数和负数，找出来和最大的子数组

79、16瓶水中有1瓶水有毒，小白鼠喝了有毒的水1个小时后会死，一个小白鼠可以喝多瓶水，一瓶水也可以被多个小白鼠喝，现在给1个小时时间，最少需要几只小白鼠能够判断出来14瓶水是无毒的？

80、java虚拟机垃圾回收机制

81、事务隔离级别有什么？

82、concurrentHashMap实现原理？原来使用的什么锁？CAS具体如何实现的？

83、Fabric的共识机制

84、kafka不是共识机制么？

85、一个文本有很多单词，找出来其中词频最大的k个单词？如果内存读一次装不下怎么办？

86、HashMap扩容是怎么实现的？多线程同时put会存在什么问题？

87、单例怎么写，懒汉和饿汉哪个更适合多线程？

88、线程池的参数都有什么？

89、最近在看什么书？

90、比特币的共识机制？

91、项目中的监控：那个监控指标常见的有哪些？

92、微服务涉及到的技术以及需要注意的问题有哪些？

93、注册中心你了解了哪些？

94、consul 的可靠性你了解吗？

95、consul 的机制你有没有具体深入过？有没有和其他的注册中心对比过？

96、项目用 Spring 比较多，有没有了解 Spring 的原理？AOP 和 IOC 的原理

97、Spring Boot除了自动配置，相比传统的 Spring 有什么其他的区别？

98、Spring Cloud 有了解多少？

99、Spring Bean 的生命周期

100、HashMap 和 hashTable 区别？

101、Object 的 hashcode 方法重写了，equals 方法要不要改？

102、Hashmap 线程不安全的出现场景

103、线上服务 CPU 很高该怎么做？有哪些措施可以找到问题

104、聊实验室的方向和做的项目

105、说一件你最得意的事儿，最失败的事儿和最出格的事儿

106、说一件你一直在坚持的事情

107、有几百亿个数字找出其中的中位数

108、JDK 中有哪几个线程池？

109、SQL 优化的常见方法有哪些

110、SQL 索引的顺序，字段的顺序

111、查看 SQL 是不是使用了索引？（有什么工具）

112、TCP 和 UDP 的区别？TCP 数据传输过程中怎么做到可靠的？

113、说下你知道的排序算法吧

114、常用的负载均衡，该怎么用，你能说下吗？

115、你有什么问题想问我的吗？

116、class存在哪儿，jvm结构

117、stringbuffer和stringbuilder的区别

118、Object 类中的方法

119、hashcode 和 equals 方法常用地方

120、hashmap put 方法存放的时候怎么判断是否是重复的

121、Object toString 方法常用的地方，为什么要重写该方法

122、Java 中有哪些线程安全的 Map？

123、Concurrenthashmap 是怎么做到线程安全的？

124、HashTable 你了解过吗？

125、如何保证线程安全问题？

126、volatile 的原子性问题？为什么 i++ 这种不支持原子性？从计算机原理的设计来讲下不能保证原子性的原因


线程间的通信方式、异步队列、消息延迟获取；
线程池由哪些组件组成的？你用过哪些线程池、分别是怎么使用的；
什么时候多线程会发生死锁，写一个例子；
层次遍历树并输出每层的层级；
二叉树的后序遍历，非递归算法；
说一说jdk1.8中，对hashMap的优化，对concurrentHashMap的优化；
如何解决hash冲突，如果产生冲突了，怎样在hash表中找到目标值；
有1000个数据存在hashmap中，实际的数量是多少，考虑负载因子和扩容；
MySQL的主从复制是怎么做的；
MySQL的索引，使用B+树索引的好处；
MySQL性能查看；
如何优化MySQL；
Redis是怎么做缓存的。Redis是单线程还是多线程？Redis的分布式集群怎么做?
怎样利用redis处理热点数据；
分布式锁是如何实现的；
分布式消息队列有哪些？具体应用在什么场景？具体说说你使用过的？
负载均衡怎么做，以及原因，了解过集群雪崩吗？
常见的RPC有哪些？
聊下高并发场景下的削峰、限流如何实现？
谈谈TCP三次握手的过程，如果没有第三次握手，会出现什么问题。
操作系统的用户态和核心态切换条件，为什么要切换？
cap分别指什么。


1. Java基础扎实，理解IO、多线程、集合等基础框架，对JVM原理有一定的了解；熟悉Spring,MyBatis,SpringBoot等开源框架；
2. 熟悉Java OOP和并发编程技术，有大规模系统开发和设计经验；熟悉分布式系统的设计和应用，熟悉分布式、缓存、消息等机制;
3. 要求对微服务化技术具有较多的经验，并熟悉Spring系列(spring cloud, spring boot, spring data)；掌握kubernetes是一个加分项；
4. 熟悉数据库应用技术与数据库架构与原理，包括关系数据库或NoSQL；精通Java JDBC/ORM框架是一个加分项；
5. 具备良好的DevOps能力，熟练掌握Docker, bash shell script是一个加分项；
6. 具备良好的分布式高可用架构思想如一致性、幂等性、CAP等是一个加分项；
7. 具有良好的沟通能力和团队合作精神；具备CI/CD和敏捷开发管理是一个加分项；
8. 有云计算业务背景者优先。