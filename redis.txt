五、redis

redis数据结构有哪些？
string,list,set,zset,hash

Redis缓存穿透，缓存雪崩？
缓存穿透：恶意用户模拟请求许多缓存中不存在的数据，导致请求落库，造成数据库异常
解决方案：1使用互斥锁排队 2、接口限流、熔断、降级  3、布隆过滤器

接口限流、熔断、降级方案

如何使用Redis来实现分布式锁？
redis.setnx expire

Redis的并发竞争问题如何解决？
利用redis自带的incr命令
使用乐观锁的方式
在客户端加锁

Redis持久化的几种方式，优缺点是什么，怎么实现的？
RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储
save <seconds> <changes> 每隔多少秒 有多少个操作
AOF 记录日志 ，增量持久化
1、no，不调用fsync，即由操作系统自己决定何时刷新数据，这种速度很快。
2、always，每次写入追加日志后调用fsync，速度慢，但是最安全。
3、everysec，每一秒调用fsync，折中方案。

RDB存在哪些优势呢？
1). 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。
比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。
2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。
3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。
4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。

RDB又存在哪些劣势呢？
1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。
2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。

AOF的优势有哪些呢？
1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。
事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。
而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。
2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。
然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。
3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，
同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。
4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。

AOF的劣势有哪些呢？
1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。

二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），
还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。

Redis的缓存失效策略？
过期键删除策略:1、定期随机删除 2、惰性删除
内存淘汰机制：
volatile-lru ：在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把 redis 既当缓存，又做持久化存储的时候才用
allkeys-lru ： 移除最近最少使用的key （推荐）
volatile-random ： 在设置了过期时间的键空间中，随机移除一个键，不推荐
allkeys-random ： 直接在键空间中随机移除一个键
volatile-ttl ： 在设置了过期时间的键空间中，有更早过期时间的key优先移除 不推荐
noeviction ： 不做过键处理，只返回一个写操作错误。 不推荐


Redis集群，高可用，原理？
(1).Redis 集群的分片特征在于将键空间分拆了16384个槽位，每一个节点负责其中一些槽位。 
(2).Redis提供一定程度的可用性,可以在某个节点宕机或者不可达的情况下继续处理命令. 
(3).Redis 集群中不存在中心(central)节点或者代理(proxy)节点， 集群的其中一个主要设计目标是达到线性可扩展性(linear scalability)

 集群的使用公式HASH_SLOT=CRC16(key) mod 16384 计算key属于哪个槽

redis队列应用场景？
lpush,lpop,rpush,rpop

分布式使用场景（储存session）？
session,分布式锁

Redis主要有哪些功能？

Redis是单进程单线程的？
单线程

Redis为什么是单线程的？
内存数据库，
单线程减少上下文切换，
核心是基于非阻塞的 IO 多路复用机制
redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型
文件事件处理器的结构包含 4 个部分：
多个 socket
IO 多路复用程序
文件事件分派器
事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，
会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理

其它开源软件采用的模型

使用Redis的优势？

Redis单点吞吐量
qps 10万/秒 tps 8万/秒

Redis相比memcached有哪些优势？
redis 支持复杂的数据结构
redis 原生支持集群模式
redis 支持持久化
redis 单线程性能更好


Redis集群方案应该怎么做？都有哪些方案？
客户端分片
codis
原生集群

Redis读写分离模型

Redis常见性能问题和解决方案？

Redis支持的Java客户端都有哪些？官方推荐用哪个？
Redisson,Jedis，lettuce

Redis集群的主从复制模型是怎样的？

Redis集群会有写操作丢失吗？为什么？

Redis集群之间是如何复制的？
①从数据库向主数据库发送sync(数据同步)命令。
②主数据库接收同步命令后，会保存快照，创建一个RDB文件。
③当主数据库执行完保持快照后，会向从数据库发送RDB文件，而从数据库会接收并载入该文件。
④主数据库将缓冲区的所有写命令发给从服务器执行。
⑤以上处理完之后，之后主数据库每执行一个写命令，都会将被执行的写命令发送给从数据库。

Redis如何做内存优化？

Redis有哪些适合的场景？

Redis缓存一致性问题
1先更新数据库再更新缓存 （不可行）
线程A更新了数据库
线程B更新了数据库
线程B更新了缓存
线程A更新了缓存
正确结果应为缓存A数据，但是因为网络原因或者其他原因，导致缓存了B数据，出现脏数据问题
2先删除缓存再更新数据库
出现问题
请求A进行写操作，删除缓存
请求B查询发现缓存不存在
请求B去数据库查询得到旧值
请求B将旧值写入缓存
请求A将新值写入数据库
上述情景则会导致缓存不一致问题出现
使用延时双删策略
先删除再更新然后延时一段时间再更新数据库
3先更新数据库，再删缓存
缓存刚好失效
请求A查询数据库，得一个旧值
请求B将新值写入数据库
请求B删除缓存
请求A将查到的旧值写入缓存